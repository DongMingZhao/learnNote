# # 第一部分：数据结构与对象

# 一、简单动态字符串(SDS)

## 1. 定义

每个 `sds.h/sdshdr` 结构表示一个 SDS 值

```c
//保存字符串对象的结构
struct sdshdr {
    // buf 中已占用空间的长度，不计算结尾空字符，如：下图值为 5
    int len;
    // buf 中剩余可用空间的长度
    int free;
    // 数据空间，用于保存字符串
    char buf[];
};
```

![](../pics/redis/redisG1_1.png)

## 2. SDS 与 C 字符串的区别

> C 语言使用长度为 N+1 的字符数组来表示长度为 N 的字符串，且字符数组的最后一个元素总是空字符 '\0'

###1. 常数复杂度获取字符串长度

- C 字符串不记录自身长度信息，为获取字符串长度我们要一个个遍历字符数组，则复杂度是O(N)

  而 SDS 在 len 属性中记录了 SDS 本身的长度，所以获取 SDS 长度复杂度为 O(1)

  > 设置和更新 SDS 长度由 SDS 的 API 在执行时自动完成，无需任何手动修改

###2. 杜绝缓冲区溢出

- SDS API 在对 SDS 修改前，会先检查 SDS 的空间是否满足修改的需求

  > 若不满足，API 会自动将 SDS 的空间扩展至执行修改所需的大小

### 3. 减少修改字符串时带来的内存重分配次数

- C 语言每次增长或缩短 C 字符串时，都需要重新分配内存

  - 若增长字符串，如拼接，则执行之前，程序需先通过内存重分配来扩展底层数组的空间大小，否则可能会产生缓冲区溢出
  - 若缩短字符串，如截断，在执行之前，程序需通过内存重分配来释放字符串不再使用的空间，否则可能会产生内存泄漏

- SDS 通过 free 字段，实现空间预分配和惰性空间释放两种优化策略

  - **空间预分配： 用于优化 SDS 字符串增长操作**： 程序不仅为 SDS 分配所需空间，还会为 SDS 分配额外的未使用空间

    > 额外分配未使用空间数量的公式：
    >
    > - 若 SDS 修改后，属性 len 值小于 1 MB，则程序分配和 len 同样带下的未使用空间
    > - 若 SDS 修改后，属性 len 值大于 1 MB，则程序会分配 1 MB的未使用空间
    >
    > 通过空间预分配策略， Redis 可减少连续执行字符串增长操作所需的内存重分配次数

  - **惰性空间释放：用于优化 SDS 的字符串缩短操作**： 当 缩短 SDS 的字符串时，程序并不立即回收多出来的字节，而是使用 free 属性将这些字节数量记录下来，并等待将来使用

### 4. 二进制安全

> C 字符串的字符必须符合某种编码（如： ASCII），且字符串中不能包含空字符（末尾除外），则使得 C 字符串只能保存文本数据

- **SDS 会以处理二进制的方式来处理 buf 数组中的数据**

### 5. 兼容部分 C 字符串函数

- SDS 总是将保存的数据末尾设置为空字符，且总会为 buf 数组分配空间时多分配一个字节来容纳

![](../pics/redis/redisG1_2.png)

## 3. SDS API

![](../pics/redis/redisG1_3.png)

![](../pics/redis/redisG1_4.png)

# 二、链表

- 链表提供了高效的节点重排能力、顺序性的节点访问方式，且可通过增删节点来灵活调整链表的长度
- 当一个列表键包含了数量较多的元素或列表中的元素字符串较长，则redis 会使用链表作为列表键的底层实现

**链表实现**： 

使用 `adlist.h/listNode` 结构来实现：

```c
typedef struct listNode{
    //前置节点
    struct listNode *prev;
    //后置节点
    struct listNode *next;
    //节点的值
    void *value;
}listNode;
```

![](../pics/redis/redisG2_2.png)

使用 `adlist.h/list` 来操作链表

```c
typedef struct list{
    //表头节点
    listNode *head;
    //表尾节点
    listNode *tail;
    //链表所包含的节点数量
    unsigned long len;
    //节点值赋值函数；dup 函数用于复制链表节点所保存的值
    void *(*dup)(void *ptr);
    //节点值释放函数；free 函数用于释放链表节点所保存的值
    void (*free)(void *ptr);
    //节点值对比函数；match 函数用于对比链表节点所保存的值和另一个输入值是否相等
    int (*match)(void *ptr,void *key);
}list;
```

![](../pics/redis/redisG2_1.png)

**redis的链表特性如下**：

- **双端**：每个 listNode 节点带有 prev 和 next 指针，具有双向性

- **无环**：表头节点的 prev 与表尾节点的 next 都指向 NULL，对链表的访问以 NULL 为终点

- **带表头指针和尾指针**：通过 list 结构的 head 和 tail，获取头指针和尾指针的时间复杂度O(1)

- **带链表长度计数器**： 通过 list 的 len 属性，记录节点个数，获取节点个数的时间复杂度O(1)

- **多态**： 链表**使用 void\* 指针来保存节点的值**，通过 list 的 dup、free、match 三个属性为节点值设置类型特定函数，所以链表可以用于保存不同类型的值

相关 API：

![](../pics/redis/redisG2_3.png)

![](../pics/redis/redisG2_4.png)

# 三、字典

- 字典，又称符号表、关联数组、映射，是一种保存键值对的抽象数据结构

- 每个键（key）和唯一的值（value）关联，键是独一无二的，通过对键的操作可以对值进行增删改查

- redis中字典应用广泛，对redis数据库的增删改查就是通过字典实现的，且是采用hash的方式进行处理

- 当hash键包含了许多元素，或者元素是比较长的字符串的时候，就会用到字典作为hash键的底层实现

## 1. 字典的实现

- redis 的字典，底层是使用哈希表实现，每个哈希表有多个哈希节点，每个哈希节点保存了一个键值对

### 1. 哈希表

redis 字典所使用的哈希表由 `dict.h/dictht` 结构定义：

```c
//哈希表：每个字典都使用两个哈希表，从而实现渐进式 rehash 
typedef struct dictht {
    // 哈希表数组，里面的每个元素指向dictEntry（哈希表节点）结构的指针
    dictEntry **table;
    // 哈希表大小，即table数组的大小
    unsigned long size;
    // 哈希表大小掩码，用于计算索引值，总是等于 size - 1
    // 与哈希值一起决定一个属性应该放到table的哪个位置
    unsigned long sizemask;
    // 该哈希表已有节点的数量，即table目前已有的键值对节点数量
    unsigned long used;
} dictht;
```

![](../pics/redis/redisG3_1.png)

### 2. 哈希表节点

哈希表节点使用 `dictEntry` 结构表示，每个 dictEntry 结构都保存着一个键值对：

```c
//哈希表节点
typedef struct dictEntry {
    // 键
    void *key;
    // 值
    union {
        void *val;
        uint64_t u64;
        int64_t s64;
    } v;
    // 指向下个哈希表节点，形成链表
    // 将多个哈希值相同的键值对连接在一起，避免因为哈希值相同导致的冲突
    struct dictEntry *next;
} dictEntry;
```

![](../pics/redis/redisG3_2.png)

### 3. 字典

redis 中的字典由 `dict.h/dict` 结构表示：

```c
//字典
typedef struct dict {
    // 类型特定函数
    dictType *type;
    // 私有数据
    void *privdata;
    // 哈希表
    // 每项是一个哈希表，一般只用ht[0]，只有在对ht[0]进行rehash时，才会使用ht[1]
    dictht ht[2];
    // rehash 索引，当 rehash 不在进行时，值为 -1
    int rehashidx; 
    // 目前正在运行的安全迭代器的数量
    int iterators; 
} dict;
```

type 属性和 privdata 属性是针对不同类型的键值对，为创建多态字典而设置的：

- **type 属性**： 是一个指向 dictType 结构的指针，每个 dictType 结构保存了一簇用于操作特定类型键值对的函数，Redis 会为用途不同的字典设置不同的类型特定函数
- **privdata 属性**： 保存了需要传给那些类型特定函数的可选参数

```c
// 字典类型特定函数
typedef struct dictType {
    // 计算哈希值的函数
    unsigned int (*hashFunction)(const void *key);
    // 复制键的函数
    void *(*keyDup)(void *privdata, const void *key);
    // 复制值的函数
    void *(*valDup)(void *privdata, const void *obj);
    // 对比键的函数
    int (*keyCompare)(void *privdata, const void *key1, const void *key2);
    // 销毁键的函数
    void (*keyDestructor)(void *privdata, void *key);
    // 销毁值的函数
    void (*valDestructor)(void *privdata, void *obj);
} dictType;
```

![](../pics/redis/redisG3_3.png)

## 2. 哈希算法

- 当要将一个新的键值对添加到字典里面时，程序需要先根据键值对的键计算出哈希值和索引值，然后再根据索引值，将包含新键值对的哈希表节点放到哈希表数组的指定索引上面

- **Redis 计算哈希值和索引值的方法如下**：

  - 使用字典设置的哈希函数，计算键 key 的哈希值： 

    `hash = dict->type->hashFunction(key)`

  - 使用哈希表的 sizemask 属性和哈希值，计算出索引值；根据情况不同，ht[x]可以是ht[0]或者ht[1]

    `index = hash & dict->ht[x].sizemask;`

![](../pics/redis/redisG3_4.png)

## 3. 解决键冲突

- **键冲突**： 当有两个或以上数量的键被分配到了哈希数组的同一个索引上面时

- **解决： 使用链地址法**

  > 每个哈希表节点都有一个 next 指针，多个哈希表节点可以用 next 指针构成一个单向链表，被分配到同一个索引上的多个节点用该单向链表连接起来

- **程序总是将新节点添加到链表的表头位置**

  > 因为 dictEntry 节点组成的链表没有指向链表表尾的指针**？？？不是很懂**

  ![](../pics/redis/redisG3_5.png)

## 4. rehash

- **rehash（重新散列）： 扩展和收缩哈希表**

  > - 随着操作的不断执行，哈希表保存的键值对会逐渐地增多或者减少
  > - 为了让哈希表的负载因子维持在一个合理的范围内，当哈希表保存的键值对数量太多或者太少时，程序需要对哈希表的大小进行相应的扩展或者收缩

- **rehash 步骤**： 
  - **为字典的 ht[1] 哈希表分配空间**，空间大小取决于要执行的操作和 ht[0] 当前包含的键值对数量（ht[0].used属性的值）：
    - 如果执行的是扩展操作，则 ht[1] 的大小为第一个大于等于 ht[0].used * 2 的 $2^n$
    - 如果执行的是收缩操作，则 ht[1] 的大小为第一个大于等于 ht[0].used 的 $2^n$
  - **将保存在 ht[0] 中的所有键值对 rehash 到ht[1]上面**： rehash 是指重新计算键的哈希值和索引值，然后将键值对放置到 ht[1] 哈希表的指定位置上
  - 当 ht[0] 包含的所有键值对都迁移到了 ht[1] 之后（ht[0]变为空表），释放ht[0]，**将 ht[1] 设置为ht[0]**，并在 ht[1] 新创建一个空白哈希表，为下一次rehash做准备

- **rehash 条件**： 

  > 负载因子计算公式： **负载因子 = 哈希表已保存节点数量 / 哈希表大小**
  >
  > $load\_factor = \frac{ht[0].used}{ht[0].size}$
  >
  > 即负载因子大小等于当前哈希表的键值对数量除以当前哈希表的大小

  - **扩展条件**： 

    - 服务器目前**没有在执行** BGSAVE 或者 BGREWRITEAOF 命令，且**负载因子 >=1**

    - 服务器目前**正在在执行** BGSAVE 或者 BGREWRITEAOF 命令，且**负载因子 >=5**

  - **收缩条件**：当**负载因子 <0.1** 时

## 5. 渐进式rehash

- redis 对 ht[0] 扩展或收缩到 ht[1] 的过程是渐进式、分多次的完成，以避免如果哈希表中存有大量键值对，一次性复制过程中，占用资源较多，会导致redis服务停用的问题

- 渐进式rehash过程如下：
  - 为 ht[1] 分配空间，让字典同时持有 ht[0] 和 ht[1] 两张哈希表

  - 将字典中的 rehashidx 设置成 0，表示正在rehash；rehashidx 的值默认是 -1，表示没有在rehash

  - 在 rehash 进行期间，程序处理正常对字典进行增删改查外，还顺带将 ht[0] 哈希表在 rehashidx 索引上的所有键值对数据 rehash 到 ht[1]，当 rehash 结束后 rehashidx 的值加1

  - 当某个时间节点，全部的 ht[0] 都迁移到 ht[1] 后，rehashidx 的值重新设定为 -1，表示rehash完成

-  **好处**：渐进式 rehash 采用分而治之的方式，将哈 rehash 键值对所需的计算均摊到对字典的每个增删改查中，避免集中 rehash 导致的庞大计算量

 - **注意**： 字典的删除、查找、更新会在 ht[0] 与 ht[1] 上同时进行；添加只保存到 ht[1] 上

## 6. API

![](../pics/redis/redisG3_6.png)

![](../pics/redis/redisG3_7.png)

# 四、跳跃表

- 跳跃表： 是一种有序的数据结构，它通过每个节点中维持多个指向其他节点的指针，从而实现快速访问

  > 跳跃表**平均O(logN)，最坏O(N)，支持顺序遍历查找**

- 在redis中，跳跃表作为**有序集合**的其中一种实现方式

  > 当有序集合的元素较多，或者集合中的元素是比较长的字符串，则会使用跳跃表来实现

## 1. 跳跃表的实现

#### 1. 跳跃表节点

由 `redis.h/zskiplistNode` 结构定义：

```c
// 跳跃表节点
typedef struct zskiplistNode {
    // 成员对象：指向一个字符串对象(保存着一个 SDS 值)
    robj *obj;
    // 分值：节点都按分值从大到小来排序
    double score;
    // 后退指针：用于从表尾向表头方向访问节点，每次只能后退至前一个节点
    struct zskiplistNode *backward;
    // 层： 层数数量越多，访问其他节点的速度越快
    // 创建跳跃表节点时，程序会根据幂次定律随机生成一个介于 1-32 之间的值作为 level 数组的大小，这个大小就是层的“高度”
    //幂次定律： 越大的数出现的概率越小
    struct zskiplistLevel {
        // 前进指针：指向表尾方向，用于从表头向表尾方向访问节点
        struct zskiplistNode *forward;
        // 跨度：用于记录两个节点间的距离（指向NULL的前进指针的跨度为 0）
        unsigned int span;
    } level[];
} zskiplistNode;
```

#### 2. 跳跃表



```c
// 跳跃表
typedef struct zskiplist {
    // 表头节点和表尾节点：分别指向跳跃表的表头和表尾节点
    // 通过这两个节点，程序定位表头和表尾的复杂度为 O(1)
    struct zskiplistNode *header, *tail;
    // 表中节点的数量
    unsigned long length;
    // 表中层数最大的节点的层数
    int level;
} zskiplist;
```

## 2. API

![](../pics/redis/redisG4_1.png)

# 五、整数集合

- **整数集合**： 是**集合键**的底层实现之一，当一个集合只包含整数值元素，并且这个集合的元素数量不多时，Redis就会使用整数集合作为集合键的底层实现
- **整数集合**： 是 redis 用于保存整数值的集合抽象数据结构，以保存类型为 `int16_t、int32_t、者int64_t` 的整数值，并且保证集合中不会出现重复元素

## 1. 实现

`intset.h/intset` 结构表示一个整数集合：

```c
typedef struct intset {
    // 编码方式： 决定 contents 的真正编码方式
    uint32_t encoding;
    // 集合包含的元素数量，即 contents 数组长度
    uint32_t length;
    // 保存元素的数组：是整数集合的底层实现
    // 集合数组的每个元素都是 contents 数组的一个数组项，各项在数组中按值从小到大排序，且不含重复项
    int8_t contents[];
} intset;
```

## 2. 升级

- 每当我们要将一个新元素添加到整数集合里面，并且新元素的类型比整数集合现有所有元素的的类型都要长时，整数集合需要先进行升级，然后才能将新元素添加到整数集合里面

- **升级整数集合并添加新元素的步骤**：

  - 根据新元素的类型，扩展整数集合底层数组的空间大小，并为新元素分配空间
  - 将底层数组现有的所有元素都转换成与新元素相同的类型，并将类型转换后的元素放置到正确的位上，而且在放置元素的过程中，需要继续位置底层数组的有序性质不变

  - 将新元素添加到底层数组里面

- **好处**：
  - **提升整数集合的灵活性**，可以随意将 `int16，int32，int64` 的值放入集合
  - **尽可能地节约内存**

- **新元素摆放位置**：
  - 在新元素小于所有现有元素时，新元素被放置在底层数组的最开头（索引 0）
  - 在新元素大于所有现有元素时，新元素被放置在底层数组的最末尾（索引 length - 1）

- 整数集合不支持降级操作

## 3. API

![](../pics/redis/redisG5_1.png)

# 六、压缩列表

- **压缩列表(ziplist)**： 是**列表键和哈希键**的底层实现之一

- 当一个列表键只包含少量列表项，并且每个**列表项要么就是小整数值，要么就是长度比较短的字符串**，那么Redis就会使用压缩列表来做列表键的底层实现

## 1. 压缩表构成

- 压缩列表是 Redis 为了节约内存而开发的，是由一系列特殊编码的连续内存块组成的顺序型数据结构

- 一个压缩表可包含多个节点，每个节点可保存一个字节数组或一个整数值

![](../pics/redis/redisG6_1.png)

## 2. 压缩表节点的构成

- **每个压缩列表节点可以保存一个字节数组或者一个整数值**

  > - **字节数组**：
  >   - 长度 $<= 63(2^6 - 1)$ 字节的字节数组
  >   - 长度 $<= 16383(2^{14} - 1)$ 字节的字节数组
  >   - 长度 $<= 4294967295(2^{32} - 1)$ 字节的字节数组
  > - **整数值**：
  >   - 4 位长，介于0到12之间的无符号整数
  >   - 1 字节长的有符号整数
  >   - 3 字节长的有符号整数
  >   - int16_t 类型整数
  >   - int32_t 类型整数
  >   - int64_t 类型整数

- 每个压缩列表节点都由 `previous_entry_length、encoding、content` 三个部分组成：

  - `previous_entry_length`：以字节为单位，记录了压缩列表中**前一个节点的长度**

    > previous_entry_length **属性长度为 1 字节或 5 字节**：
    >
    > - 若前一节点的长度 **<254 字节**，则属性长度为 1 字节：前一节点的长度就保存在这一字节里
    > - 若前一节点的长度 **>=254 字节**，则属性长度为 5 字节：第一个字节被设置为 0xFE，之后的四字节保存前一节点的长度

    > 因为有了这个长度，所以程序可以通过指针运算，根据当前节点的起始地址来计算出前一个节点的起始地址，压缩列表的从表尾向表头遍历操作就是使用这一原理实现的

  ![](../pics/redis/redisG6_2.png)

  - `encoding`：**记录了节点的 content 属性所保存数据的类型以及长度**：

    > - **一字节、两字节或者五字节长，值的最高位为00、01或者10的是字节数组编码**：
    >
    >   这种编码表示节点的 content 属性**保存着字节数组**，数组的长度由编码出去最高两位之后的其他位记录
    >
    > - **一字节长，值的最高位以11开头的是整数编码**：
    >
    >   这种编码表示节点的 content 属性**保存着整数值**，整数值的类型和长度由编码除去最高两位之后的其它位记录

     ![](../pics/redis/redisG6_3.png)

  - `content`：**负责保存节点的值**，节点值可以是一个**字节数组**或者**整数**，值的类型和长度由节点的 encoding 属性决定

## 3. 连锁更新

- **连锁更新： 连续多次空间扩展操作**

  > - 根本是由于新增节点或删除节点造成的对 previous_entry_length 的改变
  >
  > - 添加新节点或删除节点都会引发连锁更新

- 每次空间重分配的最坏复杂度为O(N)，所以连锁更新的最坏复杂度为 $O(N^2)$，平均时间复杂度为 O(N)

  > 连锁更新影响性能的概率很低：
  >
  > - 首先，压缩列表里要恰好有多个连续的、长度介于 250 字节至 253 字节之间的节点，连锁更新才可能引发（实际情况很少发生）
  > - 其次，即使出现连锁更新，一般更新节点数量不多

## 4. API

![](../pics/redis/redisG6_4.png)

# 七、对象

- **对象好处**：
  - redis 可根据对象的类型来判断该对象是否可以执行给定的命令
  - 可针对不同的使用场景，为对象设置多种不同的数据结构实现，从而优化对象的使用效率

- **对象分类**：**字符串对象、列表对象、哈希对象、集合对象、有序集合对象**

## 1. 对象的类型与编码

- Redis 使用对象来表示数据库中的键和值

redis 中的每个对象都由 `redisObject` 结构表示

```c
// Redis 对象  
typedef struct redisObject {  
    // 类型  ***
    unsigned type:4;          
    // 不使用(对齐位)  
    unsigned notused:2;  
    // 编码方式  ***
    unsigned encoding:4;  
    // LRU 时间（相对于 server.lruclock）  
    unsigned lru:22;  
    // 引用计数  
    int refcount;  
    // 指向底层实现数据结构的指针，即对象的值  ***
    void *ptr;  
} robj;
```

- 对象的 type 属性记录对象的类型

  > |   类型常量   |   对象名称   |
  > | :----------: | :----------: |
  > | REDIS_STRING |  字符串对象  |
  > |  REDIS_LIST  |   列表对象   |
  > |  REDIS_HASH  |   哈希对象   |
  > |  REDIS_SET   |   集合对象   |
  > |  REDIS_ZSET  | 有序集合对象 |

- 命令 `TYPE` 返回数据库键对应的**值对象的类型**
- 对象的 ptr 指针指向的对象的底层实现数据结构是由对象的 encoding 属性决定(编码)

![](../pics/redis/redisG7_1.png)

![](../pics/redis/redisG7_2.png)

## 2. 字符串对象

> 字符串对象的编码可以是 `int, raw, embstr` 

- 如果一个字符串对象保存的是**整数值**，并且这个整数值可以用 long 整型来表示，那么字符串对象会将整数值保存在字符串对象结构的 ptr 属性中（将void* 转换成long），并将字符串对象的**编码设置为 int**
- 如果字符串对象保存的是一个**字符串值**，并且这个**字符串的长度大于32字节**，那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串值，并将其**编码设置为 raw**

- 如果字符串对象保存的是一个**字符串值**，并且这个**字符串的长度小于等于 32 字节**，那么字符串对象将**使用 embstr 编码方式**来保存这个值

对于 embstr 编码：

- **embstr 通过调用一次内存分配函数**来分配一块连续空间，而 **raw 调用两次**，来分别**创建redisObject 结构和 sdshdr 结构**

- **好处**：
  - embstr 编码将创建字符串对象所需内存分配次数从 raw 编码的两次降为一次
  - embstr 释放内存的次数也由两次变为一次
  - embstr 编码的字符串对象的所有数据都保存在一块连续内存中，则字符串对象能更好的利用缓存带来的优势

![](../pics/redis/redisG7_3.png)

- **编码转换**： int 编码的字符串对象和 embstr 编码的字符串对象在满足条件情况下，会被转换为 raw 编码的字符串对象

  ​				

  ​							**字符串命令的实现**

|    命令     | int 编码的实现方法                                           | embstr 编码的实现方法                                        | raw 编码的实现方法                                           |
| :---------: | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
|     SET     | 使用 int 编码保存值                                          | 使用 embstr 编码保存值                                       | 使用 raw 编码保存值                                          |
|     GET     | 拷贝对象所保存的整数值并转换成字符串值， 然后返回给客户端    | 直接向客户端返回字符串值                                     | 直接向客户端返回字符串值                                     |
|   APPEND    | 将对象转换成 raw 编码， 然后按 raw编码的方式执行此操作       | 将对象转换成 raw 编码， 然后按 raw 编码的方式执行此操作      | 调用 sdscatlen 函数， 将给定字符串追加到现有字符串的末尾     |
| INCRBYFLOAT | 取出整数值并转换成 long double 类型的浮点数，并进行加法计算且将结果保存起来 | 取出字符串值并转换成long double 类型的浮点数， 并进行加法计算且将结果保存起来；若不能被转换成浮点数，则返回错误 | 取出字符串值并转换成 long double 类型的浮点数，并进行加法计算且将结果保存起来；若不能被转换成浮点数， 则返回错误 |
|   INCRBY    | 对整数值进行加法计算， 得出的计算结果会作为整数被保存起来    | embstr 编码不能执行此命令， 向客户端返回一个错误             | raw 编码不能执行此命令， 向客户端返回一个错误                |
|   DECRBY    | 对整数值进行减法计算， 得出的计算结果会作为整数被保存起来    | embstr 编码不能执行此命令， 向客户端返回一个错误             | raw 编码不能执行此命令， 向客户端返回一个错误                |
|   STRLEN    | 拷贝对象所保存的整数值且转换成字符串值， 计算并返回这个字符串值的长度 | 调用 sdslen 函数， 返回字符串的长度                          | 调用 sdslen 函数， 返回字符串的长度                          |
|  SETRANGE   | 将对象转换成 raw 编码， 然后按 raw编码的方式执行此命令       | 将对象转换成 raw 编码， 然后按 raw 编码的方式执行此命令      | 将字符串特定索引上的值设置为给定的字符                       |
|  GETRANGE   | 拷贝对象所保存的整数值且转换成字符串值， 然后取出并返回字符串指定索引上的字符 | 直接取出并返回字符串指定索引上的字符                         | 直接取出并返回字符串指定索引上的字符                         |

## 3. 列表对象

> 列表对象的编码可以是 `ziplist, linkedlist`

- ziplist 编码的列表对象**使用压缩列表作为底层实现**，每个压缩列表节点保存一个列表元素
- linkedlist 编码的列表对象**使用双端链表作为底层实现**，每个双端链表节点都保存了一个字符串对象，而每个字符串对象都保存了一个列表元素

- **编码转换**：

  > 当列表对象满足以下两个条件时，使用 ziplist 编码；不能满足使用 linklist 编码

  - 列表对象保持的所有字符串元素的长度小于 64 字节

  - 列表对象保存的元素数量小于 512 个



    ​						**列表命令的实现**

|  命令   | ziplist 编码的实现方法                                       | linkedlist 编码的实现方法                                    |
| :-----: | ------------------------------------------------------------ | ------------------------------------------------------------ |
|  LPUSH  | 调用 ziplistPush 函数， 将新元素推入到压缩列表的表头         | 调用 listAddNodeHead 函数， 将新元素推入到双端链表的表头     |
|  RPUSH  | 调用 ziplistPush 函数， 将新元素推入到压缩列表的表尾         | 调用 listAddNodeTail 函数， 将新元素推入到双端链表的表尾     |
|  LPOP   | 调用 ziplistIndex 函数定位压缩列表的表头节点， 在向用户返回节点所保存的元素之后， 调用 ziplistDelete 函数删除表头节点 | 调用 listFirst 函数定位双端链表的表头节点， 在向用户返回节点所保存的元素之后， 调用 listDelNode 函数删除表头节点 |
|  RPOP   | 调用 ziplistIndex 函数定位压缩列表的表尾节点， 在向用户返回节点所保存的元素之后， 调用 ziplistDelete 函数删除表尾节点 | 调用 listLast 函数定位双端链表的表尾节点， 在向用户返回节点所保存的元素之后， 调用 listDelNode 函数删除表尾节点 |
| LINDEX  | 调用 ziplistIndex 函数定位压缩列表中的指定节点， 然后返回节点所保存的元素 | 调用 listIndex 函数定位双端链表中的指定节点， 然后返回节点所保存的元素 |
|  LLEN   | 调用 ziplistLen 函数返回压缩列表的长度                       | 调用 listLength 函数返回双端链表的长度                       |
| LINSERT | 插入新节点到压缩列表的表头或者表尾时， 使用 ziplistPush 函数； 插入新节点到压缩列表的其他位置时， 使用 ziplistInsert 函数 | 调用 listInsertNode 函数， 将新节点插入到双端链表的指定位置  |
|  LREM   | 遍历压缩列表节点， 并调用 ziplistDelete 函数删除包含了给定元素的节点 | 遍历双端链表节点， 并调用 listDelNode 函数删除包含了给定元素的节点 |
|  LTRIM  | 调用 ziplistDeleteRange 函数， 删除压缩列表中所有不在指定索引范围内的节点 | 遍历双端链表节点， 并调用 listDelNode 函数删除链表中所有不在指定索引范围内的节点 |
|  LSET   | 调用 ziplistDelete 函数， 先删除压缩列表指定索引上的现有节点， 然后调用 ziplistInsert 函数， 将一个包含给定元素的新节点插入到相同索引上面 | 调用 listIndex 函数， 定位到双端链表指定索引上的节点， 然后通过赋值操作更新节点的值 |

## 4. 哈希对象

> 哈希对象的编码可以是 ziplist 或者 hashtable

- ziplist 编码的哈希对象使用压缩列表作为底层实现，当有新的键值对要加入到哈希对象的时候，程序先将保存了键的压缩列表节点推入到压缩列表表尾，然后将保存了值的压缩列表节点推入到压缩列表表尾

  > 因此：
  >
  > - **键值对总相邻，键在前，值在后**
  > - **先添加的键值对在表头，后添加的在表尾**

- hashtable 编码的哈希对象使用字典作为底层实现，哈希对象中的每个键值对用字典键值对保存：

  - 字典的每个**键**都是一个字符串对象，对象中**保存了键值对的键**
  - 字典的每个**值**都是一个字符串对象，对象中**保存了键值对的值**

- **编码转换**：

  > 当哈希对象满足下面两个条件时，哈希对象使用 ziplist 编码，否则使用 hashtable 编码：

  - 哈希对象保存的所有键值对的键和值的字符串的长度都小于 64 字节
  - 哈希对象保存的键值对数量小于 512 个



​							**哈希命令的实现**

|  命令   | ziplist 编码实现方法                                         | hashtable 编码的实现方法                                     |
| :-----: | ------------------------------------------------------------ | ------------------------------------------------------------ |
|  HSET   | 先调用 ziplistPush 函数， 将键推入到压缩列表的表尾， 然后再次调用 ziplistPush 函数， 将值推入到压缩列表的表尾 | 调用 dictAdd 函数， 将新节点添加到字典里面                   |
|  HGET   | 先调用 ziplistFind 函数， 在压缩列表中查找指定键所对应的节点， 然后调用 ziplistNext 函数， 将指针移动到键节点旁边的值节点， 最后返回值节点 | 调用 dictFind 函数， 在字典中查找给定键， 然后调用 dictGetVal 函数， 返回该键所对应的值 |
| HEXISTS | 调用 ziplistFind 函数， 在压缩列表中查找指定键所对应的节点   | 调用 dictFind 函数， 在字典中查找给定键                      |
|  HDEL   | 调用 ziplistFind 函数， 在压缩列表中查找指定键所对应的节点， 然后将相应的键节点、 以及键节点旁边的值节点都删除掉 | 调用 dictDelete 函数， 将指定键所对应的键值对从字典中删除掉  |
|  HLEN   | 调用 ziplistLen 函数， 取得压缩列表包含节点的总数量， 将这个数量除以 2 ， 得出的结果就是压缩列表保存的键值对的数量 | 调用 dictSize 函数， 返回字典包含的键值对数量， 这个数量就是哈希对象包含的键值对数量 |
| HGETALL | 遍历整个压缩列表， 用 ziplistGet 函数返回所有键和值（都是节点） | 遍历整个字典， 用 dictGetKey 函数返回字典的键， 用 dictGetVal 函数返回字典的值 |

## 5. 集合对象

> 集合对象的编码可以是 `intset, hashtable`

- intset 编码的集合对象使用整数集合作为底层实现，集合对象包含的所有元素都被保存在整数集合中
- hashtable 编码的集合对象使用字典作为底层实现，**字典的每个键都是一个字符串对象**，每个字符串对象包含了一个集合元素，**字典的值则全部被设置为NULL**

- 编码转换：

  > 满足条件时，对象使用 intset 编码；不满足时，使用 hashtable 编码

  - 集合对象保存的所有元素都是整数值
  - 集合对象保存的元素数量不超过 512个



|    命令     | intset 编码的实现方法                                        | hashtable 编码的实现方法                                     |
| :---------: | ------------------------------------------------------------ | ------------------------------------------------------------ |
|    SADD     | 调用 intsetAdd 函数， 将所有新元素添加到整数集合里面         | 调用 dictAdd ， 以新元素为键， NULL 为值， 将键值对添加到字典里面 |
|    SCARD    | 调用 intsetLen 函数， 返回整数集合所包含的元素数量           | 调用 dictSize 函数， 返回字典所包含的键值对数量              |
|  SISMEMBER  | 调用 intsetFind 函数， 在整数集合中查找给定的元素；若找到了说明元素存在，否则不存在 | 调用 dictFind 函数， 在字典的键中查找给定的元素；若找到了说明元素存在，否则不存在 |
|  SMEMBERS   | 遍历整个整数集合， 使用 intsetGet 函数返回集合元素           | 遍历整个字典， 使用 dictGetKey 函数返回字典的键作为集合元素  |
| SRANDMEMBER | 调用 intsetRandom 函数， 从整数集合中随机返回一个元素        | 调用 dictGetRandomKey 函数， 从字典中随机返回一个字典键      |
|    SPOP     | 调用 intsetRandom 函数， 从整数集合中随机取出一个元素， 再返回给客户端之后， 调用 intsetRemove 函数删除 | 调用 dictGetRandomKey 函数， 从字典中随机取出一个字典键， 再返回给客户端之后， 调用 dictDelete 函数删除 |
|    SREM     | 调用 intsetRemove 函数， 从整数集合中删除所有给定的元素      | 调用 dictDelete 函数， 从字典中删除所有键为给定元素的键值对  |

## 6. 有序集合对象

> 有序集合的编码： 一种是 `ziplist`，另一种是 `skiplist与dict的结合`

- ziplist 编码的压缩列表对象使用压缩列表对象作为底层实现，每个集合元素使用两个紧挨在一起的压缩节点来保存，**第一个节点保存元素的成员，第二个节点保存元素的分值**

  > 集合元素按分值从小到大排序，即**分值小靠近表头，分值大靠近表尾**

- skiplist 编码的有序集合对象使用 zset 结构作为底层实现，一个 zset 结构包含一个字典和一个跳跃表

- **编码的转换**：

  > 当有序集合对象满足下面条件时，使用ziplist编码；否则使用 skiplist 编码

  - 有序集合保存的元素数量小于128个
  - 有序集合保存的所有元素成员的长度都小于64 字节



|   命令    | ziplist 编码的实现方法                                       | zset 编码的实现方法                                          |
| :-------: | ------------------------------------------------------------ | ------------------------------------------------------------ |
|   ZADD    | 调用 ziplistInsert 函数， 将成员和分值作为两个节点分别插入到压缩列表 | 先调用 zslInsert 函数， 将新元素添加到跳跃表， 然后调用 dictAdd 函数， 将新元素关联到字典 |
|   ZCARD   | 调用 ziplistLen 函数， 获得压缩列表包含节点的数量， 并除以 2 得出集合元素的数量 | 访问跳跃表数据结构的 length 属性， 直接返回集合元素的数量    |
|  ZCOUNT   | 遍历压缩列表， 统计分值在给定范围内的节点的数量              | 遍历跳跃表， 统计分值在给定范围内的节点的数量                |
|  ZRANGE   | 从表头向表尾遍历压缩列表， 返回给定索引范围内的所有元素      | 从表头向表尾遍历跳跃表， 返回给定索引范围内的所有元素        |
| ZREVRANGE | 从表尾向表头遍历压缩列表， 返回给定索引范围内的所有元素      | 从表尾向表头遍历跳跃表， 返回给定索引范围内的所有元素        |
|   ZRANK   | 从表头向表尾遍历压缩列表， 查找给定的成员， 沿途记录经过节点的数量， 当找到给定成员之后， 途经节点的数量就是该成员所对应元素的排名 | 从表头向表尾遍历跳跃表， 查找给定的成员， 沿途记录经过节点的数量， 当找到给定成员之后， 途经节点的数量就是该成员所对应元素的排名 |
| ZREVRANK  | 从表尾向表头遍历压缩列表， 查找给定的成员， 沿途记录经过节点的数量， 当找到给定成员之后， 途经节点的数量就是该成员所对应元素的排名 | 从表尾向表头遍历跳跃表， 查找给定的成员， 沿途记录经过节点的数量， 当找到给定成员之后， 途经节点的数量就是该成员所对应元素的排名 |
|   ZREM    | 遍历压缩列表， 删除所有包含给定成员的节点， 以及被删除成员节点旁边的分值节点 | 遍历跳跃表， 删除所有包含了给定成员的跳跃表节点。 并在字典中解除被删除元素的成员和分值的关联 |
|  ZSCORE   | 遍历压缩列表， 查找包含了给定成员的节点， 然后取出成员节点旁边的分值节点保存的元素分值 | 直接从字典中取出给定成员的分值                               |

## 7. 类型检查与命令多态

Redis 中用于操作键的命令可以分为两种类型：

- **可以对任何类型的键执行**： `DEL、EXPIRE、RENAME、TYPE、OBJECT`

- **只对特定类型的键执行**： 

  - `SET 、 GET 、 APPEND 、 STRLEN` 等命令**只能对字符串**键执行
  - `HDEL 、 HSET 、 HGET 、 HLEN` 等命令**只能对哈希键**执行
  - `RPUSH 、 LPOP 、 LINSERT 、 LLEN` 等命令**只能对列表键**执行
  - `SADD 、 SPOP 、 SINTER 、 SCARD` 等命令**只能对集合键**执行

  - `ZADD 、 ZCARD 、 ZRANK 、 ZSCORE` 等命令**只能对有序集合键**执行

### 1. 类型检查

- 在执行一个特定类型的命令之前，Redis会**检查输入键的类型**，再决定是否执行命令

- 类型特定命令所进行的类型检查是通过 redisObject 结构的 type 属性来实现：

  - 在执行一个类型特定命令之前，**服务器会先检查输入数据库键的值对象是否为执行命令所需的类型**

    > - 如果是的话，服务器就对键执行指定的命令
    >
    > - 否则，服务器将拒绝执行命令，并向客户端返回一个类型错误

### 2. 多态命令

- Redis会根据**值对象的编码方式**，选择正确的命令实现代码来执行命令

**基本的流程就是**：

1. 客户端发送命令
2. 服务器检查键的值对象是否是符合的类型对象(类型检查)， 如果不是，直接返回类型错误
3. 检查对象的编码
4. 根据编码的不同选择不同的命令来执行

## 8. 内存回收

- Redis在对象系统中构建了一个**引用计数(`reference counting`)技术来实现内存回收机制**

  > 程序可以通过跟踪对象的引用计数对象，在适当的时候自动释放对象并进行内存回收

- 每个对象的引用计数信息由`redisObject`结构中的`refcount`属性记录：

  ```c
  typedef struct redisObject{
      // ...
      // 引用计数
      int refcount;
      // ...
  }robj;
  ```

- 对象的引用计数信息会随着对象的使用状态而不断变化：

  - 在创建一个新对象，引用计数的值被初始化为 `1` 
  - 当对象被一个新程序使用时，引用计数值 `+ 1` 
  - 当对象不再被程序使用的时候，引用计数值 `- 1`
  - 引用计数值为 `0` 时，对象所占用的内存会被释放

  |     函数      | 作用                                                         |
  | :-----------: | ------------------------------------------------------------ |
  | incrRefCount  | 将对象的引用计数值增一                                       |
  | decrRefCount  | 将对象的引用计数值减一， 当对象的引用计数值等于 0 时， 释放对象 |
  | resetRefCount | 将对象的引用计数值设置为 0 ， 但并不释放对象， 这个函数通常在需要重新设置对象的引用计数值时使用 |

## 9. 对象共享

- **对象的引用计数属性还有对象共享的作用**

- redis 让多个键共享同一个值对象需要执行的步骤：
  - **将数据库键的值指针指向一个现有的值对象**
  - **将被共享的值对象的引用计数 +1**

- 创建共享字符串对象的数量可以修改 `redis.h/REDIS_SHARED_INTEGERS` 常量

- 注意： **redis 只对包含整数值的字符串对象进行贡献**

  > 当服务器考虑将一个共享对象设置为键的值对象时， 程序需要**先检查给定的共享对象和键想创建的目标对象是否完全相同**
  >
  > - 如果共享对象是保存整数值的字符串对象， 那么验证操作的复杂度为 O(1) ；
  > - 如果共享对象是保存字符串值的字符串对象， 那么验证操作的复杂度为 O(N) ；
  > - 如果共享对象是包含了多个值对象， 那么验证操作的复杂度将会是 O(N^2) 

## 10. 对象的空转时长

- redisObject 结构包含的**属性`lru`记录了对象最后一次被命令程序访问的时间**

- `BJECT IDLETIME` 命令可以打印出给定键的空转时长

  > **空转时长**： 是通过将当前时间减去键的值对象的 `lru` 时间计算得出

- `BJECT IDLETIME` 命令在访问键的值对象时，不会修改值对象的lru属性

- **键的空转时长作用**： 

  - 可以被 `OBJECT IDLETIME` 命令打印出来

  - 空转时长较高的键会优先被服务器释放， 从而回收内存

    > - 如果服务器打开了 `maxmemory` 选项， 且服务器用于回收内存的算法为 `volatile-lru` 或者 `allkeys-lru` 
    > - 且当服务器占用的内存数超过了 `maxmemory` 选项所设置的上限值时

# \# 单机数据库的实现

# 八、数据库

## 1. 服务器中的数据库

- redis 服务器将所有数据库都保存在服务器状态 `redis.h/redisServer` 结构的 db 数组中

- db 数组的每项都是一个 `redis.h/redisDb` 结构

- 每个 redisDb 结构代表一个数据库：

  ```c
  struct redisServer{
      //...
      //一个数组，保存服务器中的所有数据库
      redisDb *db;
      //服务器的数据库数量：值由服务器配置的 database 选项决定，默认为 16
      int dbnum;
      //...
  };
  ```

  ![](../pics/redis/redisG8_1.png)

##2. 切换数据库

- redis 客户**端默认目标数据库为0号数据库**，可以通过 **SELECT 命令来切换目标数据库**

- 客户端状态 redisClient 结构的 db 属性记录了客户端当前的目标数据库，这个属性是指向redisdb 结构的指针

  > redisClient.db 指针指向 redisServer.db 数组的其中一个元素，而被指向的元素就是客户端的目标数据库

  ```c
  typedef struct redisClient{
      //记录客户端当前正在使用的数据库
      redisDb *db;
      //...
  } redisClient;
  ```

## 3. 数据库键空间

- Redis 是一个键值对数据库服务器，服务器中的每个数据库都由一个 `redis.h/redisDb` 结构表示

- redisDB 的 dict 字典保存了数据库中的所有键值对，我们将这个字典称为**键空间**

**键空间和用户所见的数据库是直接对应的**：

- **键空间的键也就是数据库的键**，每个键都是一个字符串对象

- **键空间的值也就是数据库的值**，每个值可以是字符串对象，列表对象，哈希表对象，集合对象和有序集合对象中任意一种 Redis 对象

**读写键空间时的维护操作**：

> 当使用Redis命令对数据库进行读写时，服务器不仅对键空间执行指定的读写操作，还会执行一些额外的维护工作

- 更新服务器的键空间命中次数和未命中次数

  > 可在 INFO stats 命令的 keyspace_hits 属性和 keyspace_misses 属性中查看

- 读取一个键之后，服务器会更新键的 LRU 时间，可用于计算键的闲置时间

  > 可使用命令 `OBJECT idletime<key>` 查看 

- 读取一个键发现键已经过期了，那么服务器会删除这个过期键，然后才执行余下的其他操作

- 如果有客户端使用 `WATCH` 命令监视某个键，被修改之后会记为脏（dirty），让事务程序注意到这修改

- 每次修改一个键之后，都会对脏（dirty）键计数器的值增1，这个计数器会触发服务器的持久化以及复制操作

- 若开启数据库通知功能，则键的修改触发数据库通知功能

##4. 过期键

**设置键的生存时间或过期时间**：

- 通过命令 `EXPIRE 或 PEXPIRE`，可以**以秒或者毫秒为键设置生存时间**

  > 命令 `SETEX` 在设置一个字符串键的同时可为键设置过期时间

　　数据库主要由dict和expires两个字典构成，其中dict负责保存键值对，expires负责保存键的过期时间

- 设置键的生存时间或过期时间命令：
  - `EXPIRE <key> <ttl>`： 用于将键 key 的生存时间设置为 ttl 秒
  - `PEXPIRE <key> <ttl>`： 用于将键 key 的生存时间设置为 ttl 毫秒
  - `EXPIREAT <key> <timestamp>`： 用于将键 key 的过期时间设置为 timestamp 所指定的秒数时间戳
  - `PEXPIREAT <key> <timestamp>`： 用于将键 key 的过期时间设置为 timestamp 所指定的毫秒数时间戳

**保存过期时间**： redisDb 结构的 expires 字典保存了数据库中所有键的过期时间，该字典成为过期字典：

- **过期字典的键是一个指针**，指向键空间中的某个键对象（即某个数据库键）
- **过期字典的值是一个 long long 类型的整数**，保存了键所指向的数据库键的过期时间（毫秒精度的UNIX时间戳）

**移除过期时间**： 命令 `PERSIST` 可以移除一个键的过期时间

**计算并返回剩余生存时间**： **命令 TTL 以秒为单位返回， PTTL 以毫秒为单位返回**

**过期键删除**：

> redis 服务器实际使用的是惰性删除和定期删除，合理达到使用 CPU 时间与内存浪费的平衡

- **定时删除**： 在设置键的过期时间时，创建一个定时器，让定时器在键的过期时间来临时，立即执行对键的删除操作

  > **优点**：（对内存友好） 保证键及时删除，且所占用内存
  >
  > **缺点**： （对 CPU 不友好） 过期键较多时，会占用许多 CPU 时间，影响服务器的响应时间和吞吐量

- **惰性删除**： 每次从键空间获取键时，都检查键是否过期；若过期则删除该键，否则返回该键

  > **优点**：（对 CPU 友好） 取键时才进行过期检查且仅删除当前处理的键
  >
  > **缺点**： （对内存不友好） 不能及时释放过期键所占内存，有内存泄漏危险
  >
  > **实现**： 由 `db.c/expireIfNeeded` 函数实现

- **定期删除**： 每隔一段时间，程序就对数据库进行检查，删除里面的过期键

  > **实现**： 由 `redis.c/activeExpireCycle` 函数实现

**AOF、RDB和复制功能对过期键的处理**：

- **RDB**：

  - **生成 RDB 文件**： 命令 `SAVE 或 BGSAVE` 创建新 RDB 文件时，会过滤已过期的键

  - **载入 RDB 文件**：

    - **若以==主==服务器模式运行，会过滤过期键** 

    - **若以==从==服务器模式运行，会载入所有键** 

      > 因为主从服务器进行数据同步时，从服务器会被清空，所以过期键不会影响从服务器

- **AOF**： 
  - **AOF 文件写入**： 过期键不会影响 AOF 文件；当过期键被删除后，AOF 文件会追加一条 DEL 命令来显示记录该键已被删除
  - **AOF 重写**：重写时，会过滤过期键

- **复制**： **复制模式下，从服务器的过期键删除由主服务器控制**

## 5. 数据库通知

- 该功能可让客户端通过订阅给定的频道或模式，来获知数据库中键的变化，以及数据库中命令的执行情况
- 配置 `notify-keyspace-events` 决定服务器发送通知类型：
  - `AKE`： 发送所有类型的键空间通知和键事件通知
  - `AK`： 发送所有类型的键空间通知
  - `AE`： 发送所有类型的键事件通知
  - `K$`： 只发送和字符串键有关的键空间通知
  - `El`： 只发送和列表键有关的键空间通知

**发送通知**： 发送数据库的通知的功能是由 `notif.c/notifyKeyspaceEvent` 函数实现： 

> `void notifyKeyspaceEvent(int type, char *event, robj *key, int dbid)`
>
> - `type`： 就是想要发送的通知类型
> - `event、key 和 dbid`： 分别是事件的名称、产生事件的键以及产出时间的数据库号码

# 九、RDB 与 AOF 持久化

## 1. RDB 持久化

- **数据库状态**： 服务器中的非空数据库以及他们的键值对统称

- **RDB持久化**： 将 Redis 在内存中的数据库状态保存到磁盘里面，避免数据意外丢失

  > - RDB 可以手动执行，也可以定期执行
  >
  > - 可以将某个时间点上的数据库状态保存到RDB文件中
  > - 通过该文件也可以还原数据库状态

- **RDB文件**： 是一个经过压缩的二进制文件，由多个部分组成

### 1. RDB 文件的创建于载入

**RDB 文件的创建**： 命令`SAVE、BGSAVE `

- `SVAE`： 会阻塞 Redis 服务器进程，知道 RDB 文件创建完毕为止，在服务器进程阻塞期间，服务器不能处理任何命令请求
- `BGSAVE`： 派生出一个子进程，由子进程负责创建RDB文件，服务器进程(父进程)继续处理命令请求

**RDB 文件的载入**：服务器启动时，会自动载入，由函数 `rdb.c/rdbLoad` 完成

> **注意**： 只有 AOF 关闭时，才会使用 RDB 文件来还原数据库状态

**自动间隔性保存**： `save` 选项可让服务器每隔一段时间自动执行一次 `BGSAVE` 命令

> - 服务器程序会根据 save 选项所设置的保存条件，设置服务器状态`redisServer`结构的`sasveparams`属性
>
> - `sasveparams`属性是一个数组，数组中的每一个元素都是一个`sasveparam`结构，，每个`sasveparam`结构都保存了一个save选项设置的保存条件：
>
>   ```c
>   struct saveparam{
>       // 秒数
>       time_t seconds;
>       // 修改数
>       int change;
>       //修改计数器：记录距上次 SAVE或BGSAVE 后，数据库状态的修改次数
>       long long dirty;
>       //UNIX时间戳：记录上一次执行 SAVE或BGSAVE 的时间
>       time_t lastsave;
>   };
>   ```

### 2. RDB 文件结构

![](../pics/redis/redisG9_1.png)

- `REDIS`： 长度5字节，保存着“REDIS”五个字符，**用于快速检查所载入的文件是否是RDB文件**
- `db_version`： 长度4字节，值是一个字符串表示的整数，这个整数**记录了RDB文件的版本号**
- `databases`： 包含零个或任意多个数据库，以及各个数据库中的键值对数据：

> 每个非空数据库都可以保存为 `SELECTDB、db_number、key_value_pairs` 三个部分
>
> ![](../pics/redis/redisG9_2.png)
>
> - `SELECTDB`： 长度是1字节，通知读入程序确定下一个要读入的是数据库号码
>
> - `db_number`： 保存着一个数据库号码，根据号码的大小不同，长度可以是1字节、2字节、5字节
>
>   > 当程序读入 db_number 部分后，服务器会调用 SELECT 命令，根据读入的数据库号码进行数据库切换，使得之后读入的键值对可以载入到正确的数据库中
>
> - `key_value_pairs`： 保存着数据库中的所有键值对数据
>
>   > - 如果键值对中带有过期时间，那么过期时间会和键值对保存在一起
>   >
>   > - 不带过期时间的键值对在RDB文件中由`TYPE`、`key`、`value`三部分组成
>   >
>   >   - `TYPE`： 记录 value 的类型，长度为 1 字节
>   >
>   >   - `key`： 是一个字符串对象
>   >   - `value`： 保存值对象
>   >
>   > - 带过期时间的键值对在RDB文件中由`EXPIRETIME`_MS、`ms`、`TYPE`、`key`、`value`组成
>   >
>   >   - `EXPIRETIME_MS`： 长度为 1 字节，它告知读入程序，接下来读入的是一个以毫秒为单位的过期时间
>   >   - `ms`： 是一个 8 字节长的带符号整数，记录着一个以毫秒为单位的UNIX时间戳，这个时间戳就是键值对的过期时间
>
>

- 如果服务器的数据库状态为空，则这个部分也为空，长度为 0 字节

- 如果服务器的数据库状态为非空，则这个部分也为非空

  > 根据数据库所保存键值对的数量、类型和内容不同，这个部分的长度也不同

- `EOF`： 长度是 1 字节，这个常量标识着 RDB 文件正文内容的结束，当程序遇到这个值的时候，就表明所有数据库中的**键值对已载入完毕**

- `check_sum`： 8 字节长的无符号整数，保存着一个校验和

  > - 该校验和是程序通过对 REDIS、db_version、databases、EOF 四个部分进行计算得到
  > - 服务器在载入 RDB 文件时，会将载入数据所计算出的校验和与 check_sum 所记录的校验和进行对比，以此来**检查 RDB 文件是否有出错或者损坏的情况出现**

## 2. AOF 持久化

> - AOF持久化是通过保存Redis服务器**所执行的写命令**来记录数据库状态的
> - RDB持久化是通过保存数据库中的键值对来记录数据库状态

### 1. AOF 的实现

AOF 持久化功能实现的三个步骤：

- **命令追加**： 当服务器执行完一个**写命令**之后，就会以协议格式**将被执行的写命令追加到服务器状态的`aof_buf`缓冲区的末尾**

- **文件写入**
- **文件同步**

> - 为了提高文件的写入效率，现代操作系统通常会将写入数据暂时保存在一个内存缓冲区里面， 等到缓冲区的空间被填满、或者超过了指定的时限之后， 才真正地将缓冲区中的数据写入到磁盘里面
>
> - 系统提供 `fsync 和 fdatasync` 同步函数， 强制让操作系统立即将缓冲区中的数据写入到硬盘里面， 从而确保写入数据的安全性

### 2. AOF 的效率和安全性

服务器配置 `appendfsync` 选项的值直接决定 AOF 持久化功能的效率和安全性

- 值为 `always` ： 服务器在每个事件循环都要将 `aof_buf` 缓冲区中的所有内容写入到 AOF 文件，并且**同步 AOF 文件**

  > - 效率是最慢的
  > - 是最安全的

- 值为 `everysec`： 服务器在每个事件循环都要将 `aof_buf` 缓冲区中的所有内容写入到 AOF 文件，并且**每隔一秒**就要在子线程中队 AOF 文件进行一次同步

- 值为 `no` ： 服务器在每个事件循环都要将 `aof_buf` 缓冲区中的所有内容写入到 AOF 文件中，由操作系统控制何时对 AOF 文件进行同步

  > - 速度最快

### 3. AOF 文件的载入与还原

- 因为 AOF 文件里包含了重建数据库状态的所有写命令，所以服务器**只要读入并重新执行一遍 AOF 文件中保存的写命令**，就可以还原服务器关闭之前的数据库状态

- Redis 读取 AOF 文件并还原数据库状态的详细步骤：

  - 创建一个不带网络连接的伪客户端

    > - Redis 的命令只能在客户端上下文执行，且载入 AOF 文件时的命令来源于AOF 文件
    > - 服务器使用一个伪客户端来执行 AOF 文件保存的写命令

  - 从AOF文件中分析并读取出一条写命令

  - 使用伪客户端执行被读出的写命令

  - 重复步骤2、步骤3直到 AOF 文件的所有写命令被处理完为止

### 4. AOF 重写

- **AOF文件重写**：**为解决 AOF 文件体积膨胀问题**，通过读取服务器当前数据库状态来实现

  > - 创建一个新的 AOF 文件替代现有的AOF文件
  >
  > - 新旧文件保存的数据库状态相同
  > - 新的文件不包含任何浪费空间的冗余命令

- **AOF 重写通过子进程来完成**

  > 目的：
  >
  > - 子进程进行 AOF 重写时，服务器进程(父进程)能继续执行命令请求
  > - 子进程带有服务器进程的数据副本，使用子进程可以在避免使用锁的情况下，保证数据的安全性

- redis 设置一个 **AOF 重写缓冲区**来解决子进程重写的数据不一致问题

  > - redis 执行一个写命令后，会同时将写命令发送给 AOF 缓冲区和 AOF 重写缓冲区
  >
  > - 子进程重写期间，服务器执行的工作：
  >
  >   - 执行客户端发来的命令
  >   - 将执行后的写命令追加到 AOF 缓冲区
  >   - 将执行后的写命令追加到 AOF 重写缓冲区
  >
  >   ![](../pics/redis/redisG9_3.png)
  >
  > - 这样就能保证：
  >
  >   - AOF 缓冲区的内容会被定期被写入和同步到AOF文件，对现有AOF文件的处理工作会如常进行
  >   - 从创建子进程开始，服务器执行的所有写命令都会被记录到 AOF 重写缓冲区中

- 当**子进程完成重写工作后**，父进程会调用一个信号处理函数，并执行以下工作：

  - 将 AOF 重写缓冲区的所有内容写入到新 AOF 文件中
  - 将新的 AOF 文件进行改名，原子地覆盖现有的AOF文件

- 重写过程中，**只有调用信号处理函数会阻塞服务器进程**

# 十、事件

Redis 服务器是一个事件驱动程序，服务器需处理两类事件：

- **文件事件**： Redis 服务器通过套接字与客户端进行连接，而文件事件就是服务器对套接字操作的抽象

  > 服务器与客户端的通信会产生相应的文件时间，而服务器则通过监听并处理这些事件来完成一系列的网络通信操作

- **时间事件**： Redis服务器中的一些操作需要在给定时间点执行，而时间事件就是对这类定时操作的抽象

## 1. 文件事件

- **文件时间处理器**： Redis 基于**Reactor模式**开发的网络事件处理器

  > - 文件时间处理器使用 **I/O 多路复用程序来同时监听多个套接字**，并根据套接字目前执行的任务为套接字关联不同的事件处理器
  > - 当被监听的套接字准备好执行连接应答、读取、写入、关闭等操作时，与操作相对应的文件事件就产生，这时文件时间处理器就会调用套接字之前关联好的时间处理器来处理这些事件
  >
  > 文件处理器通过使用I/O多路复用程序来监听多个套接字：
  >
  > - 既实现了高性能的网络通信模型
  > - 又很好的与 Redis 服务器中其他单线程运行模块进行对接

- **文件事件处理器的构成**：

  - **套接字**： 当一个套接字准备好执行连接应答、写入、读取、关闭等操作时，会产生一个文件事件，**多个文件事件可能会并发出现**
  - **I/O 多路复用程序**： 总是会将所有产生事件的套接字放到一个队列里面，然后通过这个队列以有序、同步、每次一个套接字的方式向文件事件分派器传送套接字
  - **文件事件分派器**： 接收I/O多路复用程序传来的套接字，根据套接字产生的时间类型，调用相应事件处理器
  - **事件处理器**： 是一个函数，定义某个时间发生时，服务器应执行的动作

  ![](../pics/redis/redisG10_1.png)

## 2. 时间事件

- 时间事件分类：
  - **定时事件**：让一段程序在指定时间执行一次
  - **周期性事件**：让一段程序每隔指定时间执行一次

- **时间事件的三个属性**：

  - `id`： 服务器为时间事件创建的全局唯一ID，从小到大递增

  - `when`：记录时间事件到达时间， 毫秒精度的UNIX时间戳

  - `timeProc`： 时间事件处理器，一个函数

    > 时间事件到达时，服务器调用相应的服务器处理事件

- 时间事件类型取决于时间事件处理器的返回值：

  - 如果事件处理器返回 `ae.h/AE_NOMORE`，则为定时事件

    > 该事件达到一次之后就会被删除，之后不会到达

  - 如果返回一个`非 AE_NOMORE` 的整数值，则为周期性事件

    > - 当一个时间事件到达后，服务器会根据事件处理器的返回值，对属性 when 进行更新
    >
    > - 让这个事件在一段时间之后再次到达，并以这种方式一直更新并运行

## 3. 事件的调度与执行

- 事件的调度和执行由 `ae.c/aeProcessEvents` 函数执行

![](../pics/redis/redisG10_2.png)

- 事件的调度和执行规则：

  - `aeApiPoll` 函数的最大阻塞时间由到达时间最接近当前时间的时间事件决定

    > - 既可避免服务器对时间事件进行频繁的轮询
    >
    > - 也可确保 `aeApiPoll` 函数不会阻塞过长时间

  - 等待并处理完随机出现的文件事件后，若未有时间事件到达，则继续处理文件事件

    > 随着文件事件的执行，时间会逐渐向时间事件所设置的到达时间逼近，并最终处理时间事件

  - 对文件事件和时间事件的处理都是同步、有序、原子的执行

    > 服务器不会中断事件处理，也不hi对事件进行抢占

  - 时间事件的实际处理时间会比所设定的到达时间稍晚

    > 因为时间事件在文件事件后执行，且事件之间不会出现抢占

#十一、客户端与服务器

- redis 服务器是典型的一对多服务器程序，一个服务器与多个客户端建立网络连接，每个客户端可以向服务器发送命令请求，而服务器则接收并处理客户端发送的命令请求，并向客户端返回命令回复

- 通过使用由I/O多路复用技术实现的文件事件处理器，Redis 服务器使用单线程单进程的方式来处理命令请求，并与多个客户端进行网络通信

- 对于每个与服务器进行连接的客户端，服务器都为这些客户端建立了相应的 `redis.h/redisClient` 结构（客户端状态），这个结构保存了客户端当前的状态信息，以及执行相关功能时需要用到的数据结构，其中包括：

  ```c
  typedef struct redisClient {
      // 套接字描述符
      int fd;
      // 当前正在使用的数据库
      redisDb *db;
      // 当前正在使用的数据库的 id （号码）
      int dictid;
      // 客户端的名字
      robj *name;            
      // 查询缓冲区
      sds querybuf;
      // 查询缓冲区长度峰值
      size_t querybuf_peak;  
      // 参数数量
      int argc;
      // 参数对象数组
      robj **argv;
      // 记录被客户端执行的命令
      struct redisCommand *cmd, *lastcmd;
      // 请求的类型：内联命令还是多条命令
      int reqtype;
      // 剩余未读取的命令内容数量
      int multibulklen;      
      // 命令内容的长度
      long bulklen;         
      // 回复链表
      list *reply;
      // 回复链表中对象的总大小
      unsigned long reply_bytes; 
      // 已发送字节，处理 short write 用
      int sentlen;            
      // 创建客户端的时间
      time_t ctime;          
      // 客户端最后一次和服务器互动的时间
      time_t lastinteraction; 
      // 客户端的输出缓冲区超过软性限制的时间
      time_t obuf_soft_limit_reached_time;
      // 客户端状态标志
      int flags;             
      // 当 server.requirepass 不为 NULL 时,代表认证的状态:  0 代表未认证， 1 代表已认证
      int authenticated;      
      // 复制状态
      int replstate;          
      // 用于保存主服务器传来的 RDB 文件的文件描述符
      int repldbfd;           
      // 读取主服务器传来的 RDB 文件的偏移量
      off_t repldboff;       
      // 主服务器传来的 RDB 文件的大小
      off_t repldbsize;      
      
      sds replpreamble;      
      // 主服务器的复制偏移量
      long long reploff;     
      // 从服务器最后一次发送 REPLCONF ACK 时的偏移量
      long long repl_ack_off; 
      // 从服务器最后一次发送 REPLCONF ACK 的时间
      long long repl_ack_time;
      // 主服务器的 master run ID
      // 保存在客户端，用于执行部分重同步
      char replrunid[REDIS_RUN_ID_SIZE+1]; 
      // 从服务器的监听端口号
      int slave_listening_port;
      // 事务状态
      multiState mstate;      
      // 阻塞类型
      int btype;              
      // 阻塞状态
      blockingState bpop;    
      // 最后被写入的全局复制偏移量
      long long woff;         
      // 被监视的键
      list *watched_keys;     
      // 这个字典记录了客户端所有订阅的频道
      // 键为频道名字，值为 NULL
      // 也即是，一个频道的集合
      dict *pubsub_channels;  
   
      // 链表，包含多个 pubsubPattern 结构,记录了所有订阅频道的客户端的信息
      list *pubsub_patterns; // 新 pubsubPattern 结构总是被添加到表尾
      sds peerid;           
      // 回复偏移量
      int bufpos;
      // 回复缓冲区
      char buf[REDIS_REPLY_CHUNK_BYTES];
  } redisClient;
  ```

## 1. 客户端

### 1. 客户端属性

客户端状态包含的属性：

- **比较通用的属性**： 无论客户端执行的是什么工作，都要用到这些属性

- **和特定功能相关的属性**

#### 1. 套接字描述符

- 客户端状态的 `fd` 属性记录了客户端正在使用的套接字描述符

- 根据客户端类型的不同，fd 属性的值可以是-1或者大于-1的整数：
  - **伪客户端的 fd 属性的值为 -1**： 伪客户端处理的命令请求来源于 AOF 文件或者 Lua 脚本
  - **普通客户端的 fd 属性的值为大于 -1 的整数**：普通客户端使用套接字来与服务器进行通信

> 命令 `CLIENT list` 可以列出目前所有连接到服务器的普通客户端，命令输出中的 fd 域显示了连接客户端所使用的套接字描述符

#### 2. 名字

- 默认情况下，连接到服务器的客户端是没有名字的。

- 命令`CLIENT setname` 可为客户端设置一个名字，让客户端的身份变得更清晰

- 客户端的名字记录在客户端状态的`name` 属性中

#### 3. 标志

- 客户端的标志属性 `flags` 记录了客户端的角色，以及客户端目前所处的状态

- 每个标志使用一个常量表示

  一部分标志**记录了客户端的角色**：

  - `REDIS_MASTER` 标志表示客户端代表的是一个主服务器， `REDIS_SLAVE` 标志表示客户端代表的是一个从服务器

  - `REDIS_PRE_PSYNC` 标志表示客户端代表的是一个版本低于 Redis 2.8 的从服务器， 主服务器不能使用 PSYNC 命令与这个从服务器进行同步

    > 这个标志只能在 `REDIS_SLAVE` 标志处于打开状态时使用

  - `REDIS_LUA_CLIENT` 标识表示客户端是专门用于处理 Lua 脚本里面包含的 Redis 命令的伪客户端

  另外一部分标志记**录了客户端目前所处的状态**：

  - `REDIS_MONITOR` 标志表示客户端正在执行 `MONITOR` 命令

  - `REDIS_UNIX_SOCKET` 标志表示服务器使用 UNIX 套接字来连接客户端

  - `REDIS_BLOCKED` 标志表示客户端正在被 `BRPOP, BLPOP` 等命令阻塞

  - `REDIS_UNBLOCKED` 标志表示客户端已经从 `REDIS_BLOCKED` 标志所表示的阻塞状态中脱离出来， 不再阻塞。

    > REDIS_UNBLOCKED 标志只能在 REDIS_BLOCKED 标志已经打开的情况下使用

  - `REDIS_MULTI` 标志表示客户端正在执行事务

  - `REDIS_DIRTY_CAS` 标志表示事务使用 `WATCH` 命令监视的数据库键已经被修改，`REDIS_DIRTY_EXEC` 标志表示事务在命令入队时出现了错误

    > - 以上两个标志都表示事务的安全性已经被破坏， 只要这两个标记中的任意一个被打开， EXEC 命令必然会执行失败
    > - 这两个标志只能在客户端打开了 REDIS_MULTI 标志的情况下使用

  - `REDIS_CLOSE_ASAP` 标志表示客户端的输出缓冲区大小超出了服务器允许的范围， 服务器会在下一次执行 serverCron 函数时关闭这个客户端， 以免服务器的稳定性受到这个客户端影响

    >  即存在输出缓冲区中的所有内容会直接被释放， 不会返回给客户端

  - `REDIS_CLOSE_AFTER_REPLY` 标志表示有用户对这个客户端执行了 `CLIENT_KILL` 命令， 或者客户端发送给服务器的命令请求中包含了错误的协议内容

    > 服务器会将客户端积存在输出缓冲区中的所有内容发送给客户端， 然后关闭客户端

  - `REDIS_ASKING` 标志表示客户端向集群节点（运行在集群模式下的服务器）发送了 ASKING 命令
  - `REDIS_FORCE_AOF` 标志强制服务器将当前执行的命令写入到 AOF 文件里面
  - `REDIS_FORCE_REPL` 标志强制主服务器将当前执行的命令复制给所有从服务器

  - 在主从服务器进行命令传播期间， 从服务器需要向主服务器发送 `REPLICATION ACK` 命令， 在发送这个命令之前， 从服务器必须打开主服务器对应的客户端的 `REDIS_MASTER_FORCE_REPLY` 标志， 否则发送操作会被拒绝执行

#### 4. 输入缓冲区

- 输入缓冲区用于保存客户端发送的命令请求

#### 5. 命令与命令参数

- 服务器将客户端发送的命令请求保存到客户端的 `querybuf` 属性中后
- 服务器会对命令请求的内容进行解析
- 并将得出的命令参数以及命令参数的个数分别保存到客户端状态的 `argv` 属性和 `argc` 属性

#### 6. 命令的实现函数

- 当服务器分析得到 `argv` 属性和 `argc` 属性之后，服务器根据`argv[0]`的值，在**命令表**中查找命令所对应的命令实现函数

#### 7. 输出缓冲区

- 执行命令后得到的命令回复会被保存到客户端状态的输出缓冲区里
- 每个客户端都有两个缓冲区可用：
  - 一个固定大小缓冲区： 保存长度较小的回复
  - 一个可变大小缓冲区： 板寸长度较大的回复

#### 8. 身份验证

- 客户端状态的 `authenticated` 属性记录客户单是否通过了身份验证

#### 9. 时间

- `ctime` 属性： 记录了创建客户端的时间，用于计算客户端与服务器已经连接了多少秒

  > `CLIENT list` 命令的 age 域记录了这个秒数

- `lastinteraction` 属性： 记录客户端与服务器最后一次互动的时间

  > 互动： 指的是客户端向服务器发送命令请求，或者服务器向客户端发送命令回复

- `obuf_soft_limit_reached_time` 属性： 记录了输出缓冲区第一次到达软件限制的时间

### 2. 客户端的创建与关闭

#### 1. 普通客户端

- **创建**： 普通客户端使用 `connect` 函数连接服务器的时候，服务器会调用事件处理器，为客户端创建相应的客户端状态，并将这个新的客户端状态添加到服务器状态结构 `clients` 链表的末尾

- **关闭**：

  **关闭的原因**：

  - 客户端进程退出或被杀死

  - 客户端向发送了不符合协议格式的命令请求

  - 客户端成为 `CLIENT KILL` 命令的目标

  - 客户端的空转时间超过服务器设置的 `timeout` 选项

  - 客户端发送的命令请求的代销超过了输入缓冲区的显示大小(默认1GB)

  - 客户端的命令回复超过了输出缓冲区的限制大小

  **服务器使用两种方式限制客户端输出缓冲区的大小**：

  - **硬性限制**： 如果输出缓冲区超过了硬性限制，立马关闭客户端

  - **软性限制**： 
    - 输出缓冲区超过了软性限制，而没超过硬性限制，则服务器将使用客户端状态结构的`obuf_soft_limit_reached_time` 属性记录客户端达到软性限制的起始时间，监视客户端
    - 输出缓冲区一直超过软性限制，并且持续时间超过服务器设定的时长，则服务器将关闭客户端
    - 在指定时间内，不再超过软性限制，那么客户单不会被关闭，并且`obuf_soft_limit_reached_time` 的值会被清零

- 使用 `client-output-buffer-limit` 选项为普通、从服务器、执行发布与订阅功能的客户端分别设置不同的软性或者硬性限制：

  命令格式：`client-output-buffer-limit <class> <hard limt> <soft limit< <soft seconds>`

#### 2. Lua 脚本的伪客户端

- 服务器会在初始化时创建负责执行 Lua 脚本中包含的Redis命令的伪客户端，并将这个伪客户端关联在服务器状态结构的 `lua_client` 属性中

- `lua_client` 伪客户端会在服务器运行的整个生命周期中一直存在，当服务器关闭时才关闭

#### 3. AOF 文件的伪客户端

- 服务器在载入 AOF 文件时，会创建用于执行 AOF 文件包含的 Redis 命令的伪客户端
- 在载入 AOF 完成之后，关闭这个伪客户端

## 2. 服务器

- Redis 服务器负责与多个客户端建立网络连接，处理客户端发送的命令请求
- 在数据库中保存客户端执行命令所产生的数据，并通过资源管理来维持服务器自身的运转

### 1. 命令请求的执行过程

#### 1. 发送命令请求

![](../pics/redis/redisG11_1.png)

#### 2. 读取命令请求

当客户端与服务器之间的连接套接字因为客户端的写入变成可读时，服务器会调用命令请求处理器执行一下操作： 

- 读取套接字中协议格式的命令请求，并保存到客户端状态的输入缓冲区中
- 对输入缓冲区中的命令请求进行分析，提取出命令请求中包含的命令参数，以及命令参数的个数，然后分别将参数和参数个数保存到客户端状态的 argv 和 argc 属性中去

- 调用命令执行器，执行客户端指定的命令

#### 3. 命令执行器

##### 1. 查找命令

- 命令执行器的第一件事是根据客户端状态的 `argv[0]` 参数，在命令表中查找参数所指定的命令，并将找到的命令保存到客户端的 `cmd` 属性中

- 命令表是一个字典，键是命令的名字，值是 `redisCommand` 结构，每个 `redisCommand` 记录了一个 Redis 命令的实现信息

![](../pics/redis/redisG11_2.png)

![](../pics/redis/redisG11_3.png)

##### 2. 执行预备操作

在真正执行命令之前， 程序还需要进行一些预备操作：

- 检查客户端状态的 cmd 指针是否指向 NULL 

  > 如果是的话，那么说明用户输入的命令名字找不到相应的命令实现，服务器不再执行后续步骤， 并向客户端返回一个错误

- 根据客户端 cmd 属性指向的 redisCommand 结构的 arity 属性， 检查命令请求所给定的参数个数是否正确

  > 当参数个数不正确时，不再执行后续步骤，直接向客户端返回一个错误

- 检查客户端是否已经通过了身份验证， 未通过身份验证的客户端只能执行 AUTH 命令

  > 如果未通过身份验证的客户端试图执行除 AUTH 命令之外的其他命令， 那么服务器将向客户端返回一个错误

- 如果服务器打开了 maxmemory 功能，那么在执行命令之前，先检查服务器的内存占用情况，并在有需要时进行内存回收，从而使得接下来的命令可以顺利执行

  > 如果内存回收失败，那么不再执行后续步骤，向客户端返回一个错误

- 如果服务器上一次执行 `BGSAVE` 命令时出错，并且服务器打开了 `stop-writes-on-bgsave-error` 功能，且服务器即将要执行的命令是一个写命令，则服务器将拒绝执行这个命令，并向客户端返回一个错误

- 如果客户端当前正在用 `SUBSCRIBE` 命令订阅频道，或者正在用 `PSUBSCRIBE` 命令订阅模式

  > 则服务器只会执行客户端发来的 `SUBSCRIBE, PSUBSCRIBE, UNSUBSCRIBE, PUNSUBSCRIBE` 四个命令

- 如果服务器正在进行数据载入，那么客户端发送的命令必须带有 `l` 标识才会被服务器执行

- 如果服务器因为执行 Lua 脚本而超时并进入阻塞状态，那么服务器只会执行客户端发来的 `SHUTDOWN nosave` 命令和 `SCRIPT KILL` 命令

- 如果客户端正在执行事务， 那么服务器只会执行客户端发来的 `EXEC, DISCARD, MULTI, WATCH` 四个命令

- 如果服务器打开了监视器功能，那么服务器会将要执行的命令和参数等信息发送给监视器

当完成了以上预备操作之后， 服务器就可以开始真正执行命令了

##### 3. 调用命令的实现函数

当服务器要执行命令时，它执行以下语句：`client->cmd->proc(client);`

##### 4. 执行后续操作

在执行完实现函数之后，服务器还需要执行一些后续工作：

- 如果服务器开启了慢查询日志功能，那么慢查询日志模块会检查是否需要为刚刚执行完的命令请求添加一条新的慢查询日志
- 根据刚刚执行命令所耗费的时长，更新被执行命令的 `redisCommand` 结构的 `milliseconds` 属性， 并将命令的 `redisCommand` 结构的 `calls` 计数器的值增一
- 如果服务器开启了 AOF 持久化功能，那么 AOF 持久化模块会将刚刚执行的命令请求写入到 AOF 缓冲区里面

- 如果有其他从服务器正在复制当前这个服务器，那么服务器会将刚刚执行的命令传播给所有从服务器

#### 4. 将命令回复发给客户端

- 当客户端套接字为可写状态时，命令回复处理器会将保存在客户端输出缓冲器中的命令回复发给客户端
- 命令回复发送完后，回复处理器会清空客户端状态的输出缓冲区

#### 5. 客户端接收并打印命令回复

![](../pics/redis/redisG11_4.png)

### 2. serverCron 函数

- `erverCron` 函数每100毫秒执行一次，负责管理服务器资源，并保持服务器自身的良好运转

#### 1. 更新服务器时间缓存

- 服务器状态中的 `unixtime` 属性和 `mstime` 属性被用作当前时间的缓存

  > `serverCron`函数每100毫秒更新一次这个数据

#### 2. 更新 LRU 时钟

- 服务器状态中的 `lruclock` 属性保存服务器的 LRU 时钟，是服务器时间缓存之一
- 每个对象都有一个 lru 属性，用于保存对象最后一次被命令访问的时间
- 当服务器要计算一个数据库键的空转时间，程序会用服务器的 `lruclock` 属性减对象的 `lru` 属性的值，得出结果

> `serverCron` **每10秒**更新一次 lruclock 的值

#### 3. 更新服务器每秒执行命令次数

#### 4. 更新服务器内存峰值记录

####5. 处理 SIGTERM 信号

####6. 管理客户端资源

####7. 管理数据库资源

####8. 执行被延迟的 BGREWRITEAOF

####9. 检查持久化操作的运行状态

####10. 将 AOF 缓冲区的内容写入到AOF文件

####11. 关闭异步客户端

####12. 增加 cronloops 计数器的值

### 3. 初始化服务器

#### 1. 初始化服务器状态结构

- 第一步： 创建一个 `struct redisServer` 类型的实例变量 `server` 作为服务器的状态，并为结构中的各个属性设置默认值

- 初始化 `server` 变量的工作由 `redis.c/initServerConfig` 函数完成

  ```c
  void initServerConfig(void){
      // 设置服务器的运行id
      getRandomHexChars(server.runid,REDIS_RUN_ID_SIZE);
      // 为运行id加上结尾字符
      server.runid[REDIS_RUN_ID_SIZE] = '\0';
      // 设置默认配置文件路径
      server.configfile = NULL;
      // 设置默认服务器频率
      server.hz = REDIS_DEFAULT_HZ;
      // 设置服务器运行架构
      server.arch_bits = (sizeof(long) == 8) ? 64 : 32;
      // 设置默认服务器端口
      server.port = REDIS_SERVERPORT;
      // 设置服务器的默认RDB持久化条件和AOF持久化条件
      // 初始化服务器的 LRU 时钟
      // 创建命令表
      
      // ...
  }
  ```

#### 2. 载入配置选项

- 启动服务器的时候，用户可以通过给定配置参数或者指定配置文件来修改服务器的默认配置

#### 3. 初始化服务器数据结构

服务器状态的数据结构：

- 命令表

- `server.clients` 链表：记录了与服务器相连的客户端状态结构

  > 链表的每个节点都包含了一个 `redisClient` 结构实例

- `server.db` 数组： 包含了服务器的所有数据库

- `server.pubsub_channels` 字典：用于保存频道订阅信息

- `server.pubsub_patterns` 链表： 用于保存模式订阅信息

- `server.lua`：用于执行 Lua 脚本的 Lua 环境

- `server.slowlog` 属性：用于保存慢查询日志

除初始化数据结构，initServer 还进行一些设置：

- 为服务器设置进程信号处理器
- 创建共享对象
- 打开服务器的监听端口，并为监听套接字关联连接应答事件处理器，等待服务器正式运行时接受客户端的连接
- 为 `serverCron` 函数创建时间事件
- 若 AOF 持久化功能已打开，则打开现有 AOF 文件，否则创建并打开一个新的 AOF 文件
- 初始化服务器后台 I/O 模块

#### 4. 还原数据库状态

- 初始化 server 变量后，服务器会载入 RDB 文件或 AOF 文件，并根据文件内容来还原服务器的数据库状态

- 根据服务器是否启用了AOF持久化功能，服务器载入数据所使用的目标文件有所不同：
  - 如果开启了，那么载入 AOF 文件来还原数据库状态
  - 如果没开启，那么服务器使用 RDB 文件来还原数据库状态

#### 5. 执行事件循环

# \# 多机数据库的实现

# 十二、复制

- Redis中，可以使用 `SLAVEOF` 命令或者设置 `slaveof` 选项，让一个服务器去复制另外一个服务器，被复制的服务器称为**主服务器**，对主服务器进行复制的服务器称为**从服务器**

## 1. 旧版复制

Redis 的复制功能分为两步：

- **同步**： 用于将从服务器的数据库状态更新至主服务器当前所处的数据库状态

  > 从服务器通过向主服务器发送 `SYNC` 命令完成同步操作，步骤如下：
  >
  > - 从服务器向主服务器发送 `SYNC` 命令
  > - 收到 `SYNC` 命令的主服务器执行 `BGSAVE` 命令，在后台生成一个 RDB文件，并使用一个缓冲区记录从现在开始执行的所有写命令
  > - 当主服务器的 `BGSAVE` 命令执行完毕时，主服务器将 `BGSAVE` 命令生成的 RDB 文件发送给从服务器，从服务器接收并载入这个 RDB 文件，将自己的数据库状态更新至主服务器执行 BGSAVE 命令时的数据库状态
  >
  > - 主服务器将记录在缓冲区里面的所有写命令发送给从服务器，从服务器执行这些写命令，将自己的数据库状态更新至主服务器数据库当前的所处状态
  >
  > ![](../pics/redis/redisG12_1.png)

- **命令传播**： 用于在主服务器上的数据库状态被修改，导致主从服务器的数据库状态出现不一致时，让主从服务器的数据库状态重新回到一致

  > 主服务器将自己执行的写命令，即导致主从服务器不一致的那条写命令发送给从服务器执行，当从服务器执行了相同的写命令之后，主从服务器又回到了一致状态

Redis 复制分为两种情况：

- **初次复制**： 从服务器以前没有复制过任何主服务器，或者从服务器当前要复制的主服务器和上次复制的主服务器不同

- **断线后重复制**： 处于命令传播阶段的主从服务器因为网络原因而中断了复制，但从服务器通过自动重连接重新连接上了主服务器，并继续复制主服务器

**旧版本复制缺陷**： 对于断线后重复制，旧版本复制效率贼低

## 2. 新版复制

- **新版复制**： 为解决旧版复制断线后重连后的低效问题

  > 采用 `PSYNC` 命令来代替 `SYNC` 命令来执行复制时的同步操作

- PSYNC 的两种模式：

  - **完整重同步**： **用于处理初次复制情况**

    > 步骤基本和 SYNC 命令的执行步骤一样：都是主服务器创建并发送RDB文件，向从服务器发送保存在缓冲区里面的写命令来进行同步

  - **部分重同步**： **用于断线后重复制情况**

    > 当从服务器断线后重新连接主服务器时： 如果条件允许，主服务器可以将主从服务器连接断开期间执行的写命令发送给从服务器，从服务器只要接收并执行这些写命令，就可以将数据库更新至主服务器当前所处的状态

### 1. 部分重同步

**部分重同步由三个部分构成**：

- **主服务器的复制偏移量和从服务器的复制偏移量**： 通过对比主从服务器的复制偏移量，可以知道主从服务器是否处于一致状态

  > 主从服务器都分别维护着一个复制偏移量：
  >
  > - 主服务器每次向从服务器传播 N 个字节的数据时，就将自己的复制偏移量的值加上 Ｎ
  > - 从服务器每次接收到主服务传播来的 N 个字节的数据，就将自己的复制偏移量的值加上N

- **主服务器的复制积压缓冲区**

  > - 复制积压缓冲区是由**主服务器维护**一个**固定长度先进先出队列**，默认1MB
  >
  > - 当主服务器进行命令传播时，不仅会将命令发送给所有从服务器，还会将写命令入队到复制积压缓冲区中
  >
  > ![](../pics/redis/redisG12_2.png)
  >
  > - 断线后重连上主服务器时，从服务器会将自己的复制偏移量发送给主服务器，主服务器根据这个复制偏移量来决定对从服务器执行何种同步操作：
  >
  >   - 如果这个偏移量之后的数据(即偏移量offse+1后的开始的数据)，仍然存在于复制积压缓冲区里，主服务器将对从服务器执行部分重同步操作
  >
  >   - 如果这个偏移量之后的数据不存在与复制积压缓冲区，那么主服务器对服务器执行完整重同步操作

- **服务器的运行 ID**

  > - 每个Redis 服务器都会有自己的运行 ID
  > - 运行ID在服务器启动时自动生成，由40个随机的十六进制字符组成
  >
  >
  >
  > - 当从服务器对主服务器进行初次复制时，主服务器会将自己的运行ID传送给从服务器，从服务器将这个ID保存下来
  >
  > - 当从服务器断线后重连主服务器时，从服务器将向当前连接的主服务器发送之前保存的ID：
  >
  >   - 如果ID相同，则表示当前连接的主服务器是断线之前连接的那个服务器，主服务器可以继续执行部分重同步
  >
  >   - 如果不同，则表示当前连接的主服务器不是断线之前连接的那个主服务器，主服务器对从服务器执行完整重同步操作

### 2. PSYNC 命令实现

PSYNC 命令调用的两种方式：

- 从服务器以前**没有复制过任何主服务器**，或者之前执行过 `SLAVEOF no one` 命令，那么从服务器在开始新的复制时将向主服务器发送 `PSYNC ? -1` 命令，主动请求主服务器**进行完整重同步**

- 如果已经复制过了，那么从服务器在开始一次新的复制时将向主服务器发送 `PSYNC <runid> <offset>` 命令：

  >
  > 主服务器通过这两个参数判断应该对从服务器执行哪种同步操作
  >
  > - runid 是上一次复制的主服务器的运行 ID
  > - offset 是从服务器当前的复制偏移量

- 根据命令的不同，主服务器向从服务器返回的回复也不同：

  - 如果主服务器返回 `+FULLRESYNC <runid> <offset>`  回复，则表示主服务器将与从服务器**执行完整重同步**操作

    > - runid 是这个主服务器的运行ID，从服务器将这个ID保存下来
    > - offset 则是主服务器当前的复制偏移量，从服务器将这个值作为自己的初始化偏移量

  - 如果主服务器返回 `+CONTINUE` 回复，则**执行部分重同步**

  - 如果主服务器返回 `-ERR` 回复，表示识别不了 PSYNC 命令，从服务器将向主服务器发送 SYNC 命令，并与主服务器**执行完整同步操作**

  ![](../pics/redis/redisG12_3.png)

## 3. 复制的实现

- 通过对从服务器发送 `SLAVEOF` 命令，可以让从服务器去复制主服务器：`SLAVEOF <master_ip> <master_port>`

**redis 2.8 以上版本复制功能实现步骤**：

- 步骤1：**设置主服务器的地址和端口**

- 步骤2：**建立套接字连接**

- 步骤3：**发送 `PING` 命令**
- 步骤4：**身份验证**
- 步骤5：**发送端口信息**
- 步骤6：**同步**
- 步骤7：**命令传播**

## 4. 心跳检测

- 在命令传播阶段，从服务器默认会以每秒一次的频率，向从服务器发送命令： `REPLCONF ACK <replication_offset>`

  该命令作用：

  - **检测主从服务器的网络连接状态**

    > - 如果主服务器超过一秒钟没有收到从服务器发来的 `REPLCONF ACK` 命令，那么主服务器就知道主从服务器之间的连接出现问题了
    >
    > - 通过向主服务器发送 `INFO replication` 命令，可以看到 REPLCONF ACK 命令过去时间

  - **辅助实现 `min-slaves` 选项**

    > redis的 `min-slaves-to-write` 和 `min-slaves-max-lag` 两个选项可以**防止主服务器在不安全的情况下执行写命令**

  - **检测命令丢失**

    > 主服务器根据从服务器提交的复制偏移量，在复制积压缓冲区里找到从服务器缺少的数据，并将这些数据重新Fagin从服务器

# 十三、Sentinel(哨兵)

- 由一个或多个 Sentinel 实例组成的 **Sentinel 系统可以监视任意多个主服务器**，以及这些主服务器属下的所有从服务器，并在被监视的主服务器进入下线状态时，自动将下线主服务器属下的某个从服务器升级为新的主服务器，然后由新的主服务器代替已下线的主服务器继续处理命令请求
- **在替换了新的主服务器之后，如果之前下线的主服务器上线了，就会被降为新的主服务器的从服务器**

![](../pics/redis/redisG13_1.png)

![](../pics/redis/redisG13_2.png)

## 1. 启动并初始化Sentinel

- 启动 Sentinel 命令：

  ```
  $ redis-sentinel /path/to/your/sentinel.conf
  或者
  $ redis-sentinel /path/to/your/sentinel.conf --sentinel
  ```

- Sentinel启动后，会执行五个步骤：

  - **初始化服务器**

    > Sentinel 的本质是一个运行在特殊模式下的Redis服务器

  - **将普通 redis 服务器使用的代码转换成 Sentinel 专用代码**

  - **初始化 Sentinel 状态**

    > - 服务器会初始化一个 `sentinel.c/sentinelState` 结构(简称 “Sentinel状态”)
    >
    > - 该结构保存了服务器所有和Sentinel功能有关的状态，服务器的一般状态仍然由 `redis.h/redisServer` 结构保存
    >
    > ```c
    > typedef struct sentinelState{
    >     // 当前纪元，用于实现故障转移
    >     uint64_t current_epoch;
    >     // 保存了所有被这个 Sentinel监视的主服务器
    >     // 字典的键是主服务器的名字
    >     // 字典的值是一个指向 sentinelRedisInstance 结构的指针
    >     dict *masters;
    >     // 是否进入了 TILT 模式
    >     int tilt;
    >     // 目前正在执行的脚本数量
    >     int running_scripts;
    >     // 进入 TILT 模式的时间
    >     mstime_t tilt_start_time;
    >     // 最后一次执行事件处理器的时间
    >     mstime_t previous_time;
    >     // 一个 FIFO 队列，包含了所有需要执行的用户脚本
    >     list *scripts_queue;
    > }sentinel;
    > ```

  - **初始化Sentinel状态的 `masters` 属性** 

    > Sentinel 状态中的 masters 字典记录了所有被 Sentinel 监视的主服务器信息：
    >
    > - 字典的键是被监视主服务器的名字
    > - 字典的值是被监视主服务器对应的 `sentinel.c/sentinelRedisInstance` 结构
    >
    > ```c
    > typedef struct sentinelRedisInstance{
    >     // 标识值，记录了实例的类型，以及该实例的当前状态
    >     int flags;
    >     // 实例的名字
    >     // 主服务器的名字有用户在配置文件
    >     // 从服务器以及sentinel的名字有Sentinel自动设置
    >     // 格式 为ip：port，例如“127.0.0.1:26379”
    >     char *name;
    >     // 实例的运行ID
    >     char *runid;
    >     // 配置纪元，用于实现故障转移
    >     uint64_t config_epoch;
    >     // 实例的地址
    >     sentinelAddr *addr;
    >     // SENTINEL down-after-millseconds 选项设定的值
    >     // 实例无响应多少毫秒之后才会被判断为主观下线
    >     mstime_t down_after_period;
    >     //SENTINEL monitor <master-name> <IP> <port> <quorum>选项中的quorum参数
    >     // 判断这个实例为客观下线(objectively down)所需的支持投票数量
    >     int quorum;
    >     // SENTINEL parallel-syncs <master-name> <number> 选项的值
    >     // 在执行故障转移操作时，可以同时对新的主服务器进行同步的从服务器数量
    >     int parallel_syncs;
    >     // SENTINEL failover-timeout <master-name> <ms> 选项的值
    >     // 刷新故障迁移状态的最大时限
    >     mstime_t failover_timeout;
    >     
    >     // ...
    > }sentinelRedisInstance;
    > 
    > //其中的 addr 属性是一个指向 sentinel.c/sentinelAddr 结构的指针，这个结构保存实例的IP地址和端口号:
    > typedef struct sentinelAddr{
    >     char *p;
    >     int port;
    > }sentinelAddr;
    > ```

  - **创建连向主服务器的网络连接**

    > - Sentinel 将成为主服务器的客户端，可以向主服务器发送命令，并从命令回复中获取相关的信息
    >
    > - 每个被 Sentinel 监视的主服务器，Sentinel 会创建两个连向主服务器的异步网络连接：
    >
    >   - **命令连接**： 用于向主服务器发送命令，并接收命令回复
    >
    >   - **订阅连接**： 用于订阅主服务器的 ` __sentinel__:hello` 频道

## 2. 获取服务器信息

### 1. 获取主服务器信息

- Sentinel 默认每十秒一次，通过命令连接向被监视的主服务器发送 `INFO` 命令，并通过分析 INFO 命令回复来获取主服务器当前信息

  - **关于服务器本身的信息**： 包括 `run_id` 域记录的服务器运行 ID，以及 `role` 域记录的服务器角色

  - **关于主服务器属下的所有从服务器信息**： 根据IP地址和端口号，Sentinel 可以自动发现从服务器

    > 每个从服务器： 
    >
    > - 一个 “slave” 字符串开头的行记录
    >
    > -  `ip=` 域记录了从服务器的IP地址
    >
    > - `port=` 域记录了从服务器的端口号

- 根据 run_id 域和 role 域的信息，Sentinel 将对主服务器的实例结构进行更新；主服务器返回的从服务器信息，将会被用于更新主服务器实例结构的 slaves 字典

  > - 字典的键是由 Sentinel 自动设置的从服务器名字，格式为 `ip:port`
  > - 字典的值是从服务器对应的实例结构

- Sentinel 分析 INFO 命令中包含的从服务器信息时，会检查从服务器对应的实例结构是否已经存在于 slaves 字典

  > - 如果存在，就对从服务器的实例结构进行更新
  >
  > - 如果不存在(表明这个从服务器是新发现的从服务器)，Sentinel 会在 slaves 字典中为这个从服务器创建一个新的实例结构

- **主从服务器实例结构的区别**：

  - 主服务器实例结构的 flags 值为 `SRI_MASTER`，从服务器是 `SRI_SLAVE`

  - 主服务器实例结构的 **name 由用户使用 Sentinel 配置文件设置**

    从服务器的 name 是**由 Sentinel 根据服务器 ip+port 自动设置**

### 2. 获取从服务器信息

当 Sentinel 发现主服务器**有新从服务器**时：

- **为这个新从服务器创建相应的实例结构**
- **创建连接到从服务器的命令连接和订阅连接**

**创建命令连接后，每10秒一次向从服务器发送 INFO 命令**

并根据回复分析提取以下信息：

- 从服务器的运行 ID `run_id`
- 从服务器的角色 `role`
- 主服务器的ip地址 `master_host` 以及主服务器的端口号 `master_port`
- 主从服务器的连接状态 `master_link_status`
- 从服务器的优先级 `slave_priority`
- 从服务器的复制偏移量 `slave_repl_offset`

>  根据这些信息，Sentinel 会对从服务器的实例结构进行更新

## 3. 向服务器发送信息

- **每两秒一次**，Sentinel 通过命令连接向所有被监视的主服务器和从服务器发送以下格式的命令：

  ```c
  PUBLISH __sentinel__:hello "<s_ip>,<s_port>,<s_runid>,s_epoch>,<m_name>,<m_ip>,<m_port>,<m_epoch>"
  ```

- 这条命令就表示向服务器的 `__sentinel__:hello` 频道发送一条信息，信息由以下部分组成：

- 以 `s_` 开头的参数记录 Sentinel 本身的信息
- 以 `m_` 开头的参数则是主服务器的信息，若监视的是从服务器，这个信息表示的是从服务器的信息

## 4. 接收服务器的频道信息

- 在建立起订阅连接后，Sentinel 会通过该连接，向服务器发送以下命令： `SUBSCRIBE __sentinel__:hello`

![](../pics/redis/redisG13_3.png)

## 5. 检测下线状态

### 1. 检测主观下线状态

- 默认情况下，Sentinel会以每秒一次的频率向所有与它创建了命令连接的实例发送 PING 命令，并通过实例返回的 PING 命令回复来判断实例是否在线

- 实例对 PING 指令的回复情况：

  - **有效回复**：实例返回 `+PONG, -LOADING, -MASTERDOWN` 三种中的一种
  - **无效回复**：除了上面三种之外的其它回复，或者在指定时限内没有返回任何回复

- `down-after-millseconds` 选项： 指定了 Sentinel 判断实例进入主观下线所需的时间长度

  > - 如果一个实例在 down-after-millseconds 毫秒内，连续向Sentinel返回无效回复，那么Sentinel会修改这个实例所对应的实例结构
  >
  > - 在结构的 flags 属性中打开 `SRI_S_DOWN` 标识，用于表示这个实例已经进入主观下线状态

- **注**：

  - **主观下线时长选项**，即 down-after-down 的值

    > - 不仅会被Sentinel用于判断主服务器的主观下线状态
    >
    > - 还会被用于判断主服务器属下的所有从服务器，以及所有同样监视这个主服务器的其他Sentinel的主观下线状态

  - **多个Sentinel设置的主观下线时长可能不同**

    > 设置的 down-after-milliseconds 选项的值可能不同：
    >
    > 当一个Sentinel将主服务器判断为主观下线时，其它Sentinel可能任然会认为主服务器处于在线状态

### 2. 检测客观下线状态

- 当Sentinel将一个主服务器判断为主观下线之后，为确定这个服务器是否真的下线，它会向同样监视这个主服务器的其它Sentinel进行询问
- 当接收到足够数量的已下线判断之后，Sentinel 就会将从服务器判定为客观下线，并对主服务器进行故障转移操作

**检测客观下线状态**：

- 发送 `SENTINEL is-master-down-by-addr` 命令

  > Sentinel会发送下面的命令询问其它Sentinel是否同意主服务器下线：`SENTINEL is-master-down-by-addr <ip> <port> <current_epoch> <runid>`

- 接收 `SENTINEL is-master-down-by-addr` 命令

  > - 当目标 Sentinel 接收到源 Sentinel 发来的 `SENTINEL is-master-by-addr` 命令时
  >
  > - 目标 Sentinel 会分析并取出命令请求中包含的各个参数，并根据其中的IP和port，判断主服务器是否已经下线
  >
  > - 然后向源 Sentinel 返回一个包含三个参数的 `Multi Bulk` 回复：
  >
  >   - `<down_state>`： 返回目标 Sentinel 对主服务器的检查结果，1表示主服务器已下线，0表示主服务器未下线 
  >
  >   - `<leader_runid>`： 可以是 `*` 符号或者目标Sentinel的局部领头Sentinel的运行ID
  >
  >     > - `*` 表示命令仅仅用于检测主服务器的下线状态
  >     > - 局部领头Sentinel的运行ID则用于选举领头Sentinel
  >
  >   - `<leader_epoch>`： 目标Sentinel的局部领头Sentinel的配置纪元，用于选举领头Sentinel
  >
  >     > - 仅在 leader_runid 值不为 `*` 时有效
  >     >
  >     > - 如果其值为 `*` ，则 leader_epoch 总为 0

- 接收 `SENTINEL is-master-down-by-addr` 命令的回复

  > - Sentinel将统计同意主服务器下线的数量
  > - 当这个值达到配置指定的判断客观下线所需的数量时(即 quorum 属性的值)：
  >   - Sentinel 会将主服务器实例结构中 flags 属性的 `SRI_O_DOWN` 标识打开，标识主服务器已经进入客观下线状态

## 6. 选举领头Sentinel

- 当一个主服务器被判断为客观下线时，监视这个下线主服务器的各个 Sentinel 会进行协商，选举出一个领头Sentinel，并**由领头Sentinel对下线主服务器进行故障转移操作**

- **选举领头Sentinel的规则和方法**：
  - 所有在线 Sentinel 都有成为领头 Sentinel 的机会
  - 无论选举成功与否，所有 Sentinel 配置纪元都会进行自增
  - 在配置纪元里，所有 Sentinel 都有一次将某个 Sentinel 设置为局部领头的机会；且一旦设置，不能更改
  - 每个发现主服务器进入客观下线的 Sentinel 都会要求其他 Sentinel 将自己设置为局部领头
  - 当源 Sentinel 向目标 Sentinel 发送 `SENTINEL is-master-down-by-addr` 命令，且命令中的 `runid` 参数不是 `*` 符号而是源 Sentinel  的运行 ID时，表示目标 Sentinel  将前者设置为后者的局部领头 Sentinel 
  - **设置局部领头规则是先到先得**
  - 若某个 Sentinel 被半数以上的 Sentinel  设置为局部领头，则这个 Sentinel  会成为领头 Sentinel 
  - 在每个配置纪元里，只会出现一个领头 Sentinel 
  - 在给定时间内，没有选出领头 Sentinel ，则会进行再次选举，知道选出为止

## 7. 故障转移

- 在选举产生出领头Sentinel之后，**领头Sentinel将对已下线的主服务器进行故障转移操作**：

**操作步骤**：

- **选出新的主服务器**： 在已下线的主服务器属下的所有从服务器中，挑选一个从服务器作为主服务器

- **修改从服务器的复制目标**： 让已下线的主服务器的所有从服务器改为复制新的主服务器

- **将旧的主服务器变为从服务器**： 将已下线主服务器设置为新的主服务器的从服务器，这个旧的主服务器重新上线时，就会成为新的主服务器的从服务器

# 十四、集群

- Redis 集群是分布式数据库方案，**通过分片来进行数据共享**，并提供复制和故障转移功能

## 1. 节点

- 一个Redis 集群通常由多个节点组成，当要组成真正可工作的集群时，需要将独立的节点连接起来，构建成一个包含多个节点的集群

  > - 连接各节点： `CLUSTER MEET <ip> <port>`
  > - 向一个节点发送上面的命令，可以让节点与 ip和port 所指定的节点进行握手，握手成功，节点就会将 ip和port 指定的节点添加到当前的集群中

### 1. 启动节点

- 节点的本质还是服务器，服务器会根据 `cluster-enabled` 配置选项来决定是否开启集群模式

  ![](../pics/redis/redisG14_1.png)

- 运行在集群模式下的节点会继续使用所有在单机模式中使用的服务器组件

### 2. 集群数据结构

- 每个节点会使用 `clusterNode` 结构来记录自己的状态，并未集群中的所有其他节点创建一个该结构

  ```c
  //一个节点的当前状态
  struct clusterNode{    
      // 创建节点的时间    
      mstime_t ctime;    
      // 节点的名字，由40个16进制字符组成    
      char name[REDIS_CLUSTER_NAMELEN];    
      // 节点标识    
      int flags;    
      // 节点当前的配置纪元，用于实现故障转移    
      uint64_t configEpoch;    
      // 节点的ip地址    
      char ip[REDIS_IP_STR_LEN];    
      // 节点的端口号    
      int port；    
      // 保存连接节点所需的有关信息   
      clusterLink *link；    
      //……
  };
  ```

  **link 属性保存了连接节点所有的有关信息**：

  ```c
  typedef struct clusterLink {
      // 连接的创建时间
      mstime_t ctime;
      // TCP 套接字描述符
      int fd;
      // 输出缓冲区，保存着等待发送给其他节点的消息（message）。
      sds sndbuf;
      // 输入缓冲区，保存着从其他节点接收到的消息。
      sds rcvbuf;
      // 与这个连接相关联的节点，如果没有的话就为 NULL
      struct clusterNode *node;
  } clusterLink;
  ```

- 每个节点的 `clusterState` 结构，用于记录当前节点的视角下，集群目前所处状态

  ```c
  typedef struct clusterState {
      // 指向当前节点的指针
      clusterNode *myself;
      // 集群当前的配置纪元，用于实现故障转移
      uint64_t currentEpoch;
      // 集群当前的状态：是在线还是下线
      int state;
      // 集群中至少处理着一个槽的节点的数量
      int size;
      // 集群节点名单（包括 myself 节点）
      // 字典的键为节点的名字，字典的值为节点对应的 clusterNode 结构
      dict *nodes;
      // ...
  } clusterState;
  ```

### 3. CLUSTER MEET 命令实现

- 向节点A发送 `CLUSTER MEET` 命令，能让接收命令的节点 A 将另一个节点 B 添加到节点 A 当前所处的集群里

- 收到命令的**节点 A  和节点 B 进行握手**：

  - **节点 A 为节点 B 创建一个 clusterNode 结构**，并将该结构添加到自己的 `clusterState.nodes` 字典中

  - 节点 A 根据 `ip和port` **发送 meet 消息**给节点B

  - 节点 B 收到 meet 消息，**为节点 A 创建一个 clusterNode 结构**，并将该结构添加到自己的`clusterState.nodes` 字典中

  - 节点 B 向节点 A **返回 PONG 消息**

  - **节点 A 向节点 B 返回 PING 消息**

  - 当节点 B 接收到 PING 消息，节点 A 接收到 PONG 消息，表示握手完成

  ![](../pics/redis/redisG14_2.png)

## 2. 槽指派

- 当数据库中的 **16384** 个槽(slot)都有节点在处理时，集群处于上线状态，否则，处于下线状态

  > - redis 被分为 16384 个槽
  > - 每个键属于其中一个槽
  > - 每个节点可处理 0 个或最多 16384 个槽

- 向节点发送 `CLUSTER ADDSLOTS` 命令，可将一个或多个槽指派给节点负责

### 1. 记录节点的槽指派信息

- 结构 `clusterNode` 的 `slots, numslots` 属性记录了节点负责处理哪些槽 

  - 属性 `slots`： 二进制位数组，长度为 `16384/8=2048` 个字节，共包含 16384 个二进制位

    > redis 以 0 为起始索引，16384 为终止索引，对 slots 数组进行编号：
    >
    > - 若 slots 数组在索引 i 上的 二进制位值为 1，则表示节点负责处理槽 i
    > - 若 slots 数组在索引 i 上的 二进制位值为 0，则表示节点==不==负责处理槽 i

### 2. 传播节点的槽指派信息

- 节点除将自己负责处理的槽记录在 `clusterNode` 结构的 `slots` 属性和 `numslots`属性
- 还会将自己的 slots 数组通过消息发送给集群中其他的节点，来告知其他节点自己负责处理哪些槽

- 集群中的每个节点都会知道数据库中的 16384 个槽被指派给了哪些节点

### 3. 记录集群的槽指派信息

- 结构 `clusterState` 的 `slots` 数组记录了集群中所有的 16384 个槽指派信息

  > slots 的每项都指向一个 `clusterNode` 结构的指针：
  >
  > - 若 `slots[i]` 指向 NULL，表示槽 i 未指派给任何节点
  > - 若 `slots[i]` 指向一个 `clusterNode` 结构，表示槽 i 指派给 `clusterNode` 结构所代表的节点

### 4. CLUSTER ADDSLOTS 命令实现

- 该命令接受一个或多个槽作为参数，并将所有输入的槽指派给接收该命令的节点负责：`CLUSTER ADDSLOTS <slot> [slot ...]`

- 命令实现的**伪代码**：

  ```python
  def CLUSTER_ADDSLOTS(*all_input_slots):
      # 遍历所有输出槽,检查他们是否都是未指派槽
      for i in all_input_slots;
          # 如果有任意一个槽已经被指派给了某个节点，那么向客户端返回错误，并终止命令执行
          if clusterState.slots[i] != NULL
              reply_error()
              return;
  	# 如果所有输入槽都是未指派槽 
  	# 如果通过检查，再一次遍历所有槽，将这些槽指派给当前节点
      for i in all_input_slots;
  		# 设置clusterState.slots数组,
  		# 将slots[i]的指针指向代表当前节点的clusterNode结构
  		clusterState.slots[i] = clusterState.myself
  		# 访问当前节点的clusterNode结构的slots数组，将数组在索引i上的二进制位设置位1
  		setSlotBit(clusterState.myself.slots,i)
  	# 发送消息告知集群中的其他节点，自己目前正在负责处理那些槽
  ```

## 3. 集群中执行命令

![](../pics/redis/redisG14_3.png)

- **计算键属于哪个槽**：

  ```python
  # 计算算法
  def slot_number(key):
      # CRC16(key)： 用于计算键 key 的 CRC-16 校验和 
      # &16383: 用于计算出介于 0-16383 之间的整数作为键 key 的槽号
  	return CRC16(key) & 16383
  ```

  > 命令 `CLUSTER KETSLOT <key>`： 用于查看一个给定键属于哪个槽
  >
  > 该命令**伪代码**：
  >
  > ```python
  > def CLUSTER_KEYSLOT(key):
  > 	# 计算槽号
  > 	slot = slot_number(key);
  >     # 将槽号返回给客户端
  >     reply_client(slot);
  > ```

- **判断槽是否由当前节点负责处理**： 当节点计算出键所属槽 `i` 之后，节点会检查自己在 `clusterState.slots` 数组中的项 `i` ，判断键所处的槽是否由自己负责：

  - 如果 `clusterState.slots[i] 等于 clusterState.myself` ，说明**槽 i 由当前节点负责**，节点可以执行客户端发送的命令

  - 否则，槽 `i` 不由当前节点负责，节点会根据 `clusterState.slots[i] 所指向的 clusterNode` 结构所记录的节点 `IP和port`，向客户端返回 MOVED 错误并指引客户端转向正在处理槽 `i` 的节点

- **MOVED 错误**： 当节点发现键所在的槽并非由自己负责处理的时候，就会向客户端返回一个 `MOVED` 错误，指引客户端转向正在负责槽的节点，格式为： `MOVED <slot> <ip>:<port>`

## 4. 节点数据库的实现

- **区别**： **节点只能使用 0 号数据库**，单机服务器没有限制
- 相同点： 都能**保存键值对及键值对过期时间**，且实现方式相同

- 节点还会用 `clusterState` 结构中的 `slots_to_keys` 跳跃表来保存槽和键之间的关系

- `slots_to_keys` 跳跃表每个节点的分值都是一个槽号，节点的成员都是一个数据库键：

  - 当节点往数据库**添加**键值对时，节点会将这个键以及键的槽号关联到 slots_to_keys 跳跃表中
  - 当节点**删除**某个键值对时，节点就会在这个跳跃表中解除被删除键和槽号之间的关联

  > 通过这个跳跃表中记录各个数据库键对应的槽，节点可以对某个或某些槽的所有数据库键进行批量操作

## 5. 重新分片

- **重新分片**： 可以将任意数量已经指派给某个节点（源节点）的槽改为指派给另一个节点（目标节点），并且相关槽所属的键值对也会从源节点移动到目标节点
- **重新分片可以在线进行，在这过程中，集群不用下线，且源节点和目标节点都可以继续处理命令请求**

**重新分片的实现原理**：

- 集群管理软件 `redis-trib`： 负责执行重新分片操作

  > `redis-trib` 通过向源节点和目标节点发送命令来进行重新分片

- `redis-trib` 对集群的单个槽 `slot` 进行重新分片的步骤：

  - 对目标节点发送 `CLUSTER SETSLOT <slot> IMPORTING <source_id>` 命令，让目标节点准备好从源节点导入槽 slot 的键值对

  - 对源节点发送 `CLUSTER SETSLOT <slot> MIGRATING <source_id>` 命令，让源节点准备好将属于槽 slot 的键值对迁移至目标节点

  - 对源节点发送 `CLUSTER GETKEYSINSLOT <slot> <count>` 命令，获得最多 count 个属于槽 slot 的键值对的键名

  - 向源节点发送一个 `MIGRATE <target_ip> <target_port> <key_name> 0 <timeout>` 命令，将被选中的键原子的从源节点迁移至目标节点
  - **重复步骤3和4**，直到源节点保存的所有属于槽 `slot` 的键值对都被迁移到目标节点为止
  - 向集群中的任意一个节点发送 `CLUSTER SETSLOT <slot> NODE <target_id>` 命令，将槽`slot`指派给目标节点的信息发送给整个集群

![](../pics/redis/redisG14_4.png)

![](../pics/redis/redisG14_5.png)

## 6. ASK 错误

- 在重新分片期间，源节点向目标节点迁移一个槽的过程中，可能会出现这样一种情况：属于被迁移槽的一部分键值对保存在源节点里面，而另一部分键值对保存在目标节点中
- 当客户端向源节点发送与数据库键有关的命令，且命令要处理的数据库键恰好属于正被迁移的槽时： 
  - 源节点先在自己的数据库里查找这个键，如果**找到就直接返回执行客户端命令**
  - 如果没找到，则这个键可能已经被迁移到了目标节点，源节点将向客户端返回一个 **ASK 错误**，指引客户端转向正在导入槽的目标节点，并再次发送之前要执行的命令

- 接到 ASK 错误的客户端会根据错误提供的IP地址和端口号，转向至正在导入槽的目标节点，然后向目标节点发送一个 `ASKING` 命令， 之后再重新发送原本想要执行的命令

- **ASK 错误和 MOVED 错误的区别**：
  - `MOVED` 错误： 代表槽的负责全已经从一个结点转移到了另一个节点
  - `ASK` 错误： 只是两个节点在迁移槽的过程中使用的一种临时措施

## 7. 命令实现

### 1. `CLUSTER SETSLOT IMPORTING`

- 格式： `CLUSTER SETSLOT <slot> IMPORTING <source_id>`
- `clusterState` 结构的 `importing_slots_from` 数组记录了当前节点正在从其他节点导入的槽

- 对集群进行重新分片时，向目标节点发送命令 `CLUSTER SETSLOT <i> IMPORTING <source_id>` 可将目标节点 `clusterState.importing_slots_from[i]` 的值设置为 `source_id` 所代表节点的 `clusterNode` 结构

### 2. `CLUSTER SETSLOT MIGRTING`

- 格式： `CLUSTER SETSLOT <i> MTGRATING <target_id>`
- `clusterState` 结构的 `migrating_slots_to` 数组记录了当前节点正在迁移至其他节点的槽
- 对集群进行重新分片时，向目标节点发送命令 `CLUSTER SETSLOT <i> MTGRATING <target_id>` 可将源节点 `clusterState.migrating_slots_to[i]` 的值设置为 `target_id` 所代表节点的 `clusterNode` 结构

### 3. `ASKING`

- **ASKING命令**： 用于打开发送该命令的客户端的 `REDIS_ASKING` 标识

  伪代码：

  ```python
  def ASKING():
  	# 打开标识
  	client.flags |= REDIS_ASKING
  	# 向客户端返回OK回复
  	reply("OK")
  ```

  ![](../pics/redis/redisG14_6.png)

## 8. 复制与故障转移

redis 集群的节点分为：

- **主节点**： 用于处理槽
- **从节点**： 用于复制某个主节点，并在被复制的主节点下线时，代替主节点继续处理命令请求

### 1. 设置从节点

- 向一个节点发送命令：`CLUSTER REPLICATE <node_id>`

- 该命令可以让接收命令的节点成为 `node_id` 所指定的从节点，并开始对主节点进行复制：

  - 接收到该命令的节点会先在自己的 `clusterState.nodes` 字典中找到 `node_id` 所对应节点的 `clusterNode` 结构，并将自己的 `clusterState.myself.slaveof` 指针指向这个结构，以此来记录这个节点正在复制的主节点
  - 然后节点修改自己在 `clusterState.myself.flags` 中的属性，关闭原本的 `REDIS_NODE_MASTER` 标识，打开 `REDIS_NODE_SLAVE` 标识，表示这个节点由原来的主节点变成了从节点

  - 最后，节点调用复制代码，并跟据 `clusterState.myself.slaveof` 指向的 `clusterNode` 结构所保存的IP地址和端口号，对主节点进行复制

    > 从节点复制主节点： 相当于向从节点发送命令 `SLAVEOF <master_ip> <maste_port>`

### 2. 故障检测

- 集群中的每个节点都会定期地想集群中的其他节点发送 PING 消息，以此来检测对方是否在线

  > 如果接受 PING 消息的节点没有在规定时间内返回 PONG ，那么发送 PING 的节点就会将接受 PING 消息的节点标记为意思下线(PFAIL)
  >
  > - 集群中的各节点会通过互相发送消息的方式来交换集群中各节点的状态信息

- 当一个主节点 A 通过消息得知主节点 B 认为主节点 C 进入疑似下线状态

  > - 主节点 A 会在自己的 `clusterState.nodes` 字典中找到主节点 C 所对应的 `clusterNode`结构，并将主节点 B 的下线报告添加到这个结构的 `fail_reports` 链表里
  >
  > - 每个下线报告由结构 `clusterNodeFailReport` 表示：
  >
  >   ```c
  >   struct clusterNodeFailReport{
  >       // 报告目标节点已经下线的节点
  >       struct clusterNode *node;
  >       // 最后一次从node节点收到下线报告的时间,程序使用这个时间戳来检查下线报告是否过期
  >       // (与当前时间相差太久的下线报告会被删除)
  >       mstime_t time;
  >   }
  >   ```

- 集群半数以上负责处理槽的主节点都将某个主节点 X 报告为疑似下线，则这个主节点 X 将被标记为已下线(FAIL)

  > - 将主节点 X 标记为已下线的节点会向集群广播一条关于主节点X的 FAIL 消息
  > - 所有收到这条 FAIL 消息的节点都会立即将主节点 X 标记为已下线

### 3. 故障转移

当一个从节点发现自己正在复制的主节点进入了已下线状态，从节点将开始对下线主节点进行故障转移:

- 复制下线主节点的所有从节点里面，会有一个从节点被选中
- 被选中的从节点将执行 `slaveof no one` 命令，成为新的主节点
- 新的主节点会撤销对已下线主节点的槽指派槽，并将这些槽全部指派给自己
- 新的主节点向集群广播一条 PONG 消息，告诉集群中的其他节点自己成为了新的主节点
- 新的主节点开始接收和自己负责处理的槽有关的命令请求，故障转移完成

### 4. 选举新的主节点

**新的主节点通过选举产生**：

- 集群的配置纪元是一个自增计数器，初始值为 0
- 当集群里的某个节点开始一次故障转移操作时，集群配置纪元的值就会加一
- 对于每个配置纪元，集群中的每个负责处理槽的主节点都有一次投票机会，而第一个向主节点要求投票的从节点将获得主节点的投票
- 当从节点发现自己正在复制的主节点已下线时，从节点会向集群广播一条 `CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST` 消息，要求所有收到这条消息、并具有投票权的主节点向这个从节点投票
- 如果一个主节点具有投票权，并且这个主节点尚未投票给其他从节点，那么主节点将向要求投票的从节点返回一条 `CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK` 消息，表示这个主节点支持从节点成为新的主节点
- 每个参与选举的从节点都会接受 `CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK` 消息，并根据自己收到了多少条这种消息来统计自己获得了多少主节点的支持
- 如果集群有 N 个具有投票权的主节点，那么当一个从节点收集到 `>=N/2+1` 张支持票时，这个从节点当选为新的主节点
- 每个具有投票权的主节点只能投一次票，则具有 `>=N/2+1` 张支持票的从节点只会有一个，即确保新主节点只会有一个
- 如果在一个配置纪元里没有从节点能收集到足够多的支持票，那么集群进入一个新的配置纪元，并再次进行选举，直到选出新的主节点为止

## 9. 消息

###1. 概述

- 集群中的各节点通过发送和接收消息来进行通信

- 节点发送的**消息正文分类**：

  - `MEET` 消息：当发送者接到客户端发送的 `CLUSTER MEET` 命令时，发送者会向接收者发送 MEET 消息，请求接收者加入发送者当前所处的集群中
  - `PING` 消息：集群里的每个节点默认每隔一秒钟就会从已知节点列表中随机选出五个节点，然后对这五个节点中最长时间没有发送过 PING 消息的节点发送 PING 消息，以此来检测选中的节点是否在线
  - `PONG` 消息：当接收者收到发送者发来的 MEET 消息或者 PING 消息时，为了向发送者确认这条 MEET 消息或者 PING 消息已到达，接收者会向发送者返回一条 PONG 消息
  - `FAIL` 消息：当一个主节点 A 判断另一个主节点 B 已经进入 FAIL 状态时，节点 A 会向集群广播一条关于 B 的 FAIL 消息，所有收到这条消息的节点都会立即将节点 B 标记为已下线

  - `PUBLISH` 消息：当节点接收到一个 PUBLISH 命令时，节点会执行这个命令，并向集群广播一条 PUBLISH 消息，所有接收到这条 PUBLISH 消息的节点都会执行相同的 PUBLISH 消息

- **消息组成**：

  - **消息头**： 记录了消息发送者自身的一些消息

    > 每个消息头都由一个 `cluster.h/clushterMsg` 结构表示：
    >
    > ```c
    > typedef struct{
    >     // 消息的长度（包括这个消息头的长度和消息正文的长度）
    >     unit32_t totlen;
    >     // 消息的类型
    >     uint16_t type;
    >     // 消息正文包含的节点信息数量,只在发送MEET、PING、PONG 等Gossip协议消息时使用
    >     uint16_t count;
    >     // 发送者所处的配置纪元
    >     uint64_t currentEpoch;
    >     // 如果发送者是一个主节点，那么这里记录的是发送者的配置纪元
    >     // 如果发送者是一个从节点，那么这里记录的是发送者正在复制的主节点的配置纪元
    >     uint64_t configEpoch;
    >     // 发送者的名字（ID）
    >     char sender[REDIS_CLUSTER_NAMELEN];
    >     // 发送者目前的槽指派信息
    >     unsigned char myslots[REDIS_CLUSTER_SLOTS/8];
    >     // 如果发送者是一个从节点，那么这里记录的是发送者正在复制的主节点的名字
    >     // 如果发送者是一个主节点，那么这里记录的是REDIS_NONE_NULL_NAME
    >     // (一个40字节长，值全为0的字节数组)
    >     char slaveof[REDIS_CLUSTER_NAMELEN];
    >     // 发送者的端口号
    >     uint16_t port;
    >     // 发送者的标识值
    >     uint16_t flags;
    >     // 发送者所处集群的状态
    >     unsigned char state;
    >     // 消息的正文
    >     union clusterMsgData data;
    > }clusterMsg;
    > ```
    >
    > `clusterMsg.data` 属性指向联合 `clusterh/clusterMsgData`，这个联合就是消息正文：
    >
    > ```c
    > union clusterMsgData{
    >     // MEET、PING、PONG消息的正文
    >     struct{
    >         // 每条MEET、PING、PONG消息都包括两个clusterMsgDataGossip结构
    >         clusterMsgDataGossip gossip[1];
    >     }ping;
    >     // FAIL消息的正文
    >     struct{
    >         clusterMsgDataFail about;
    >     }fail;
    >     // PUBLISH消息的正文
    >     struct{
    >         clusterMsgDataPublish msg;
    >     }publish;
    >     // 其他消息的正文...
    > };
    > ```
    >
    > - `clusterMsg` 结构的`currentEpoch`、`sender`、`myslots` 等属性记录了发送者自身的节点信息
    > - 接收者会根据这些信息，在自己的 `clusterState.nodes` 字典里找到发送者对应的 `clusterNode` 结构，并对结构进行更新

  - **消息正文**： 由 `MEET, PING, PONG, FAIL, PUBLISH` 等组成

### 2. 消息实现

####1. `MEET, PING, PONG`

- 集群中的各节点通过 `Gossip` 协议来交换各自关于不同节点的状态信息

  > - `Gossip` 协议由 `MEET, PING, PONG` 三种消息实现
  > - 这三种消息的正文都由两个 `cluster.h/clusterMsgDataGossip` 结构组成

- 节点通过消息头的 `type` 属性判断是三种消息中的哪一种

- 每次发送 `MEET、PING、PONG` 消息时，发送者都会从自己的已知节点中随机选出两个节点，并将这两个被选中节点的信息分别保存到两个 `clusterMsgDataGossip` 中

  ```c
  typedef struct {
      // 节点的名字
      char nodename[REDIS_CLUSTER_NAMELEN];
      // 最后一次向该节点发送PING消息的时间戳
      uint32_t ping_sent;
      // 最后一次从该节点接收到PONG消息的时间戳
      uint32_t pong_received;
      // 节点的IP地址
      char ip[16];
      // 节点的端口号
      uint16_t port;
      // 节点的标识值
      uint16_t flags;
  }clusterMsgDataGossip;
  ```

- 接收者收到消息，会取出这两个 `clusterMsgDataGossip` 结构 ，并根据其中的信息对自己的 `clusterState.nodes` 进行操作：

  - 如果被选中节点**不存在**与接收者的已知节点列表

    > 表明接收者第一次接触到被选中节点，接收者将根据结构中的 IP地址和端口号等信息，与被选中节点进行握手

  - 如果**在列表中**

    > 说明接收者已与被选中节点进行过接触，接收者将根据 `clusterMsgDataFossip` 结构记录的信息，对被选中节点所对应的 `clusterNode` 结构进行更新

####2. `FAIL`

- 在集群的节点数量比较大的情况下，单纯用 Gossip 协议来传播节点的已下线信息会给节点的信息更新带来一定延迟
- `FAIL` 消息可让集群中的所有节点立即知道某主节点已下线

- `FAIL` 消息的正文由 `cluster.h/clusterMsgDataFail` 结构表示，该结构只包含一个 `nodename` 属性，记录已下线节点的名字：

  ```c
  typedef struct {
      // 记录已下线节点的名字(名字是唯一的哦)
      char nodename[REDIS_CLUSTER_NAMELEN];
  }clusterMsgDataFail;
  ```

#### 3. `PUBLISH`

- 当客户端向集群中的某节点发送命令 `PUBLISH <channel> <message>` 时

  > - 接收到 `PUBLISH` 命令的节点不仅会向 `channel 频道`发送`消息 message`
  > - 还会向集群广播一条 PUBLISH 消息，接收这条消息的节点都会向 channel 频道发送 message 消息

- PUBLISH 消息的正文由 `cluster.h/clusterMsgDataPublish` 结构表示：

  ```c
  typedef struct{
      // 保存了channel参数的长度
      uint32_t channel_len;
      // 保存了message参数的长度
      uint32_t message_len;
      // 1. 定义为 8 字节只是为了对齐其他消息结构
      // 2. 保存了客户单通过PUBLISH命令发送给节点的channel和message参数
      // 3. 0-channel_len-1 字节保存的是channel参数；channel_len - (channel_len+message_len-1) 字节保存的是message参数
      unsigned char bulk_data[8];
  }clusterMsgDataPublish;
  ```

# \# 独立功能实现

# 十五、发布与订阅

- Redis通过发布订阅提供一对多甚至是多对多的节点消息通信，发布订阅由 `PUBLISH、SUBSCRIBE、PSUBSCRIBE、PUBSUB` 等命令组成

## 1. 频道的订阅与退订

- 当客户端执行 `SUBSCRIBE` 命令订阅某个或某些频道时，则客户端与被订阅频道间就建立了订阅关系
- 频道订阅关系保存在 `pubsub_channels` 字典中，**键是被订阅的频道，值的一个记录所有订阅频道的客户端**

### 1. 订阅

- 每当客户端进行订阅时，客户端与被订阅频道在 `pubsub_channels` 字典中进行关联
- 根据是否已有其他订阅者，关联操作可分为：
  - 若已有其他订阅者，程序将客户端添加到订阅者链表的末尾
  - 若无订阅者，，程序首先在 `pubsub_channels` 字典中为频道创建一个键，且将值设为空链表，然后将客户端添加到链表中

### 2. 退订

- 当客户端进行退订时，服务器将从 `pubsub_channels` 中解除客户端与被退订频道间的关联：
  - 程序会根据被退订频道的名字，在 `pubsub_channels` 字典中找到频道对应的订阅者链表，然后从订阅者链表中删除退订客户端信息
  - 若删除退订客户端后，链表变为空链表，则程序将从 `pubsub_channels` 字典中删除频道对应的键

## 2. 模式的订阅与退订

- 模式订阅关系保存在属性 `pubsub_patterns` 中

- 属性 `pubsub_patterns` 是一个链表，链表中的每个节点保存着 `pubsubPattern` 结构：

  ```c
  typedef struct pubsubPattern{
      //订阅模式客户端
      redisClient *client;
      //被订阅的模式
      robj *pattern;
  }pubsubPattern;
  ```

### 1. 订阅

- 客户端执行命令 `PSUBSCRIBE` 订阅模式时，服务器会对订阅模式执行以下两个操作：
  - 新建一个 `pubsubPattern` 结构，将结构的 pattern 属性设置为被订阅的模式，client 属性设置为订阅模式的客户端
  - 将 `pubsubPattern` 结构添加到 `pubsub_patterns` 链表的表尾

### 2. 退订

- 退订命令 `PUNSUBSCRIBE`： 当客户端退订模式时，服务器将在 `pubsub_patterns` 链表中查找并删除那些为被退订模式的 `pattern` 属性，且 `client` 属性为执行退订命令的客户端的 `pubsubPattern` 结构

## 3. 发送消息

当客户端执行 `PUBLISH <channel> <message>` 命令将消息 `message` 发送给频道 `channel` 时，服务器执行的操作：

- 将消息 `message` 发送给 `channel` **频道的订阅者**

  > - 在字典 `pubsub_channels` 中找到频道 `channel` 的所有订阅者名单
  > - 将消息发送给名单上的客户端

- 若 模式与频道相匹配，则将消息 `message` 发送给 `pattern` **模式的订阅者**

  > - 遍历链表 `pubsub_patterns`，查找与频道 `channel` 相匹配的模式
  > - 将消息发送给这些模式的客户端

## 4. 查看订阅消息

- 命令 `PUBSUB`： 可用来查看频道或模式的相关信息

- 命令 `PUBSUB` 的三个子命令：

  - `PUBSUB CHANNELS [pattern]`： 用于返回服务器当前被订阅的频道

    > pattern 参数可选：
    >
    > - 若不给定 pattern，命令返回服务器当前被订阅的所有频道
    > - 若给定 pattern，命令返回服务器当前与 pattern 模式相匹配的频道
    >
    > 实现伪代码：
    >
    > ```python
    > def pubsub_channels(pattern=None):
    >     # 一个列表，用于记录所有符合条件的频道
    >     channel_list = []
    >     # 遍历服务器中的所有频道，即 pubsub 字典的所有键
    >     for channel in server.pubsub_channels:
    >         # 当以下两个条件任意满足一个时，将频道添加到链表中
    >         # 1）未指定 pattern 参数
    >         # 2）指定 pattern 参数，且 channel 与 pattern 相匹配
    >         if(pattern is None) or match(channel,pattern):
    >             channel_list.append(channel)
    >     # 向客户端返回频道列表
    >     return channel_list
    > ```

  - `PUBSUB NUMSUB [channel-1,channel-2...]`： 接受任意多个频道作为输入参数，并返回这些频道的订阅者数量

    > 实现伪代码：
    >
    > ```python
    > def pubsub_numsub(*all_input_channels):
    >     # 遍历输入的所有频道
    >     for channel in all_input_channels:
    >         # 若 pubsub_channels 字典中无键 channel，则说明频道 channel 无订阅者
    >         if channel not in server.pubsub_channels:
    >             # 返回频道名
    >             reply_channel_name(channel)
    >             # 订阅者数量为 0
    >             reply_subscribe_count(0)
    >         # 若字典 pubsub_channels 存在键 channel,则说明频道 channel 有订阅者
    >         else:
    >             # 返回频道名
    >             reply_channel_name(channel)
    >             # 订阅者链表的长度就是订阅者数量
    >             reply_subscribe_count(len(server.pubsub_channels[channel]))
    > ```

  - `PUBSUB NUMPAT`：用于返回服务器当前被订阅模式的数量

# 十六、事务

- redis 通过 `MULTI, EXEC, WATCH` 等命令来实现事务功能

- 事务： 是一次性、按顺序的执行多个命令的机制，且在事务执行期间，服务器不会中断事务

  > 事务会先将命令执行完毕后，才会去处理其他客户端的命令请求

## 1. 事务的实现

事务会经历三个阶段：

- **事务开始**： `MULTI` 命令标志事务的开始

  > `MULT` 命令可将执行该命令的客户端从非事务状态转换为事务状态，通过在属性 `flags` 中打开标识 `REDIS_MULTI`

- **命令入队**： 

  > - 当客户端处于==非事务状态==时，客户端发送的命令会立即被服务器执行
  > - 当客户端处于==事务状态==时，服务器会根据客户端发送的不同命令来执行不同的操作：
  >   - **立即执行的命令**：`EXEC, DISCARD, WATCH, MULTI`
  >   - **将命令放入事务队列中，并向客户端返回 `QUEUED` 回复的命令**：除上述四个命令的其他命令
  >
  > ![](../pics/redis/redisG16_1.png)
  >
  > 事务状态包含一个事务队列及一个已入队命令的计数器(即事务队列的长度)：
  >
  > ```c
  > typedef struct multiState{
  >     //事务队列，FIFO 顺序
  >     multiCmd *commands;
  >     //已入队命令计数
  >     int count;
  > }multiState;
  > ```
  >
  > 事务队列的 multiCmd 结构包含已入队命令的相关信息：
  >
  > ```c
  > //事务队列：以 FIFO 方式保存入队命令
  > typedef struct multiCmd{
  >     //参数
  >     robj **argv;
  >     //参数数量
  >     int argc;
  >     //命令指针
  >     struct redisCommand *cmd;
  > }multiCmd;
  > ```

- **事务执行**： 命令 `EXEC` 让客户端执行事务

  > - 服务器会遍历客户端的事务队列
  > - 执行队列中保存的所有命令
  > - 最后将执行命令所得的结果返回给客户端
  >
  > EXEC 命令实现原理的伪代码：
  >
  > ```python
  > def EXEC():
  >     # 创建空白的回复队列
  >     reply_queue = []
  >     # 遍历事务队列中的每项，读取命令参数，参数个数，要执行的命令
  >     for argv,argc,cmd in client.mstate.commands:
  >         # 执行命令，并取得命令的返回值
  >         reply = execute_command(cmd,argv,argc)
  >         # 将返回值追加到回复队列末尾
  >         reply_queue.append(reply)
  >     # 移除 REDIS_MULTI 标识，让客户端回到非事务状态
  >     client.flags &= ~REDIS_MULTI
  >     # 清空客户端的事务状态，包括清零入队命令计数器，释放事务队列
  >     client.mstate.count = 0
  >     release_transaction_queue(client.mstate.commands)
  >     # 将事务的执行结果返回给客户端
  >     send_reply_to_client(client,reply_queue)
  > ```

## 2. WATCH 命令的实现

- 命令 `WATCH`： 是一个乐观锁

  - 在命令 EXEC ==执行前==，监视任意数量的数据库键

  - 在命令 EXEC ==执行时==，检查被监视的键是否至少有一个已被修改

    > 若有，服务器将拒绝执行事务，并向客户端返回代表事务执行失败的空回复

- 字典 `watched_keys`： 字典的**键是被监视的数据库键**，字典的值是一个记录了所有监视相应数据库键的客户端**链表**

  > 通过字典 `watched_keys`，服务器可知道哪些数据库键正被监视及哪些客户端正监视这些数据库键

- **监视机制的触发**： 函数 `multi.c/touchWatchKey`： 所有数据库修改命令执行后都会调用该函数对字典 `watched_keys` 进行检查

  > 查看是否有客户端在监视刚被命令修改过的数据库键：
  >
  > - 若有的话，`touchWatchKey` 函数会将监视被修改键的客户端的 `REDIS_DIRTY_CAS` 标识打开，表示该客户端的事务安全性已被破坏

- **判断事务是否安全**： 服务器会根据标识 `REDIS_DIRTY_CAS` 来决定是否执行事务

  - ###### 若标识已打开，表示键已被修改，客户端提交的事务不再安全，服务器将拒绝执行

  - 若标识未打开，表示键未被修改，客户端提交的事务安全，服务器将执行客户端提交的事务

## 3. 事务的 ACID 属性

- redis 中，事务总有 ACI(原子性，一致性，隔离性) 性质，只在某种特定持久化模式下，才具有 D(持久性) 性质

- **原子性**： 数据库将事务中的多个操作当作一个整体来执行

  > 要么执行事务的所有操作，要么都不执行
  >
  > - redis 不支持事务回滚

- **一致性**： 若数据库在执行事务前是一致的，则在事务执行后，无论事务是否成功，数据库也仍然一致

  > **一致**： 指数据符合数据库本身的定义和要求，没有包含非法或无效的错误数据
  >
  > redis 为保持事务一致性二处理错误：
  >
  > - **入队错误**： 若一个事务在入队过程中，出现命令不存在或命令格式不正确等错误，redis 将拒绝执行该事务
  >
  > - **执行错误**： 事务在执行时发生的错误
  >
  >   > **说明**：
  >   >
  >   > - 这些错误在入队时不会被发现，只会在执行时被触发
  >   > - 即使执行出错，服务器也不会中断事务的执行，且已执行的命令不会被出错的命令影响
  >
  > - **服务器停机**： 根据服务器使用的持久化模式，可分为以下情况：
  >
  >   - 若运行在无持久化的内存模式下，则重启后的数据库将是空白的
  >   - 若运行在 RDB 模式下，服务器会根据 RDB 文件来恢复数据
  >   - 若运行在 AOF 模式下，服务器会根据 AOF 文件来恢复数据

- **隔离性**： 即使数据库中有多个事务并发执行，各事务间也不会互相影响

  > - redis 使用单线程串行方式执行事务
  >
  > - 服务器在执行事务期间不会对事务进行中断

- **持久性**： 当一个事务执行完毕时，所得结果被保存到永久性存储介质中，即使服务器停机，执行事务结果也不会丢失

  > - 当服务器运行在无持久化模式下时： 一旦停机，所有服务器数据都会丢失（**不具有持久性**）
  > - 当在 RDB 模式下时，只有满足特定条件时，才会执行 `BGSAVE` 命令，且异步的 BGSAVE 不能保证数据立即保存到硬盘（**不具有持久性**）
  > - 当在 AOF 模式下且选项 `appendfsync` 值为 `always` 时，服务器将同步数据到硬盘（**具有持久性**）
  > - 当在 AOF 模式下且选项 `appendfsync` 值为 `everysec` 时，服务器每秒同步数据到硬盘，可能导致数据丢失（不具有持久性）
  > - 当在 AOF 模式下且选项 `appendfsync` 值为 `no` 时，操作系统负责同步数据到硬盘，可能在同步过程中丢失数据（不具有持久性）

# 十六、Lua 脚本





# 十七、排序

- redis 的 `SORT` 命令可对列表键、集合键、有序集合键的值进行排序

## 1. SORT \<key\> 命令实现

- 命令格式： `SORT <key>`，该命令会对包含数字值的键 key 进行排序
- 例如： `RPUSH numbers 3 1 2`，执行 `SORT numbers` 的**详细步骤**：
  - 创建一个与 numbers 长度相等的数组，数字的每项都是一个 `redis.h/redisSortObject` 结构
  - 遍历数组，将数组各项的 obj 指针指向 numbers 列表的各项，构成一对一关系
  - 遍历数组，将 obj 指针指向的列表项转换成一个 double 类型的浮点数，并保存到相应数组项的 `u.score` 属性中
  - 根据属性 `u.score` 的值，对数组进行排序
  - 遍历数组，将各数组项的 obj 指针所指向的列表项的排序结果返回给客户端

## 2. ALPHA 选项实现

- 选项 `ALPHA`： 可使 SORT 命令对字符串进行排序： `SORT <key> ALPHA`
- 例如： `SADD fruits apple banana cherry`，执行 `SORT fruits ALPHA` 的详细步骤：
  - 创建一个长度为 fruits 集合大小的 `redisSortObject` 结构数组
  - 遍历数组，将各数组项的 obj 指针指向 fruits 集合的各元素
  - 根据 obj 指针所指向的集合元素，对数组进行字符串排序
  - 遍历数组，将各数组项的 obj 指针所指向的元素返回给客户端

## 3. 选项 ASC 与 DESC 实现

- 默认情况与 `SORT <key> ASC` 执行升序排序； `SORT <key> DESC` 执行降序排序

## 4. BY 选项实现

- 默认情况，SORT 命令使用被排序键包含的元素作为排序的权重

  > 元素本身决定了元素在排序后所处的位置

- 例如： `SADD fruits "apple" "banana" "cherry"`，`MSET apple-price 8 banana-price 5.5 cherry-price 7`

  执行 `SORT fruits BY *-price` 的详细步骤：

  - 创建一个长度为 fruits 集合大小的 `redisSortObject` 结构数组
  - 遍历数组，将各数组项的 obj 指针指向 fruits 集合的各元素
  - 遍历数组，根据各数组项的 obj 指针所指向的集合元素及 BY 选项所给定的模式 `*-price` ，查找相应的权重键
  - 将各权重键转换成一个 double 类型的浮点数，并保存到相应数组项的 `u.score` 属性中
  - 根据属性 `u.score` 的值，对数组进行排序
  - 遍历数组，将各数组项的 obj 指针所指向的集合元素返回给客户端

## 5. LIMIT 选项实现

- 只返回其中的一部分元素，格式： `LIMIT <offset> <count>`

  > - `offset`：表示要跳过的已排序元素数量
  > - `count`： 表示跳过给定数量的已排序元素后，要返回的已排序元素数量

## 6. GET 选项实现

- 默认情况下，SORT 命令对键进行排序后，总是返回被排序键本身所包含的元素
- **GET 选项**： 可让 SORT 命令对键进行排序后，根据被排序的元素及 GET 选项所指定的模式，查找并返回某些键的值

## 7. STORE 选项实现

- 默认情况下，SORT 命令之向客户端返回排序结果，而不保存排序结果
- STORE 选项： 可将排序结果保存在指定的键中，如： `SORT stu ALPHA STORE sorted_stu`

## 8. 多个选项的执行顺序

- **执行过程顺序**：
  - **排序**：使用命令 `ALPHA, ASC或DESC,BY`
  - **限制排序结果集的长度**：使用命令 `LIMIT`
  - **获取外部键**：使用命令 `GET`
  - **保存排序结果集**：使用命令 `STORE`
  - **向客户端返回排序结果集**：

- **改变选项摆放顺序不会影响 SORT 命令执行顺序**（GET 选项除外）

# 十八、二进制位数组

- 命令 `SETBIT, GETBIT, BITCOUNT, BITOP` ： 用于处理二进制位数组
  - `SETBIT`： 用于为位数组指定偏移量上的二进制位设置值，位数组的偏移量从 0 开始计数，二进制位值可为 0 或 1
  - `GETBIT`： 用于获取位数组指定偏移量上的二进制位的值 
  - `BITCOUNT`： 用于统计位数组中值为 1 的二进制位的数量
  - `BITOP`： 可对多个位数组进行**按位与、按位或、按位异或、取反运算**

## 1. 位数组表示

- redis 使用字符串对象来表示位数组

  > - 字符串对象使用的 SDS 数据结构是二进制安全的
  > - 程序可直接使用 SDS 结构来保存位数组，并使用 SDS 结构的操作函数来处理位数组



## 2. 命令实现

### 1. `GETBIT`

- 命令 `GETBIT`： 用于返回位数组 bitarray 在 offset 偏移量上的二进制位的值
- 格式： `GETBIT <bitarray> <offset>`，执行过程：
  - 计算 `byte = offset / 8(向下取整)`，**byte 值**记录了 offset 偏移量指定的二进制位保存在位数组的**哪个字节**
  - 计算 `bit = (offset mod 8) + 1`，**bit  值**记录了 offset 偏移量指定的二进制位是 byte 字节的**第几位二进制位**
  - 根据 byte 值和 bit 值，在位数组 bitarray 中定位 offset 偏移量指定的二进制位，并返回这个位的值

### 2. `SETBIT`

- 命令 `SETBIT` ： 用于将位数组 bitarray 在 offset 偏移量上的二进制位的值设置为 value，并向客户端返回二进制位被设置前的旧值
- 格式： `SETBIT <bitarray> <offset> <value>`，执行过程：
  - 计算 `len = offset / 8 + 1(向下取整)`，len 值记录了保存 offset 偏移量指定的二进制位至少**需要多少字节**
  - 检查 bitarray 键保存的位数组的长度是否小于 len，若小于，则将 SDS 的长度扩展为 len 字节，并将所有新扩展空间的二进制位的值设置为 0
  - 计算 `byte = offset / 8(向下取整)`，byte 值记录了 offset 偏移量指定的二进制位保存在位数组的**哪个字节**
  - 计算 `bit = (offset mod 8) + 1`，**bit  值**记录了 offset 偏移量指定的二进制位是 byte 字节的**第几位二进制位**
  - 根据 byte 和 bit 值，将指定二进制位值保存在 oldvalue 变量，然后将新值 value 设置为该二进制位的值
  - 向客户端返回 oldvalue 变量的值

### 3. `BITCOUNT`

- 命令 `BITCOUNT`： 用于统计给定位数组中，值为 1 的二进制位的数量

- **二进制位统计算法**：

  - **遍历算法**： 遍历位数组中的每个二进制位，遇到值为 1 的二进制位时，将计数器值增一

  - **查表算法**：表的键是某种排列的位数组，表的值是相应位数组中值为 1 的二进制位的数量

    > 查表法是用空间换时间的方式

  - `variable-precision SWAR` 算法：32 位长度位数组的实现

    **汉明重量**： 统计一个位数组中非 0 二进制位的数量

    ```c
    uint32_t swar(uint32_t i){
        //步骤 1：表示可按每两个二进制位为一组进行分组，各组的十进制表示就是改组的汉明重量
        i = (i & 0x55555555) _ ((i >> 1) & 0x55555555);
        //步骤 2： 表示可按*每四个*二进制位为一组进行分组，各组的十进制表示就是改组的汉明重量
        i = (i & 0x33333333) + ((i >> 2) & 0x33333333);
        //步骤 3： 表示可按*每八个*二进制位为一组进行分组，各组的十进制表示就是改组的汉明重量
        i = (i & 0x0F0F0F0F) + ((i >> 4) & 0x0F0F0F0F);
        //步骤 4：i * (0x01010101)计算出汉明重量并保存在高八位，>>24 将汉明重量移到低八位
        i = (i * (0x01010101) >> 24);
        
        return i;
    }
    ```

- **redis 的实现**：

  - 若未处理的二进制位数量**大于等于 128 位**，使用 SWAR 算法计算汉明重量
  - 若未处理的二进制位数量**小于 128 位**，使用查表法计算汉明重量

  > - 查表法使用键长为 8 位的表
  > - SWAR 算法每次载入 128 个二进制位，通过调用四次 32 位 SWAR 算法来实现

###4. `BITOP`

- 在执行 `BITOP AND` 命令时，程序用 ==&== 操作计算出所有输入二进制位的**逻辑与**结果，并保存在制定的键上面
- 在执行 `BITOP OR` 命令时，程序用 ==|== 操作计算出所有输入二进制位的**逻辑或**结果，并保存在制定的键上面
- 在执行 `BITOP XOR` 命令时，程序用 ==^== 操作计算出所有输入二进制位的**逻辑异或**结果，并保存在制定的键上面
- 在执行 `BITOP NOT` 命令时，程序用 ==~== 操作计算出所有输入二进制位的**逻辑非**结果，并保存在制定的键上面

# 十九、慢查询日志

- **慢查询日志**： 用于记录执行时间超过给定时长的命令请求

  > 用户可通过该功能产生的日志来监视和优化查询速度

- 与慢查询日志有关的配置选项：
  - 选项 `slowlog-log-slower-than`： 指定执行时间超过多少微秒的命令请求会被记录到日志上
  - 选项 `slowlog-max-len`： 指定服务器最多保存多少条慢查询日志

##1. 慢查询记录的保存

- 命令 `SLOWLOG GET` ： 用于查看服务器所保存的慢查询日志

- 与慢查询日志功能有关的属性：

  ```c
  struct redisServer{
      //下一条慢查询日志的 ID：初始值为 0，每当创建新的慢查询日志时，会作为新日志的 id 值，并增一
      long long slowlog_entry_id;
      //保存了所有慢查询日志的链表，每个节点保存一个 slowlogEntry 结构
      list *slowlog;
      //服务器配置 slowlog-log-slower-than 选项的值
      long long slowlog_log_slower_than;
      //服务器配置 slowlog-max-len 选项的值
      unsigned long slowlog_max_len;
      //...
  }
  ```

  每个 `slowlogEntry` 结构代表一个慢查询日志：

  ```c
  typedef struct slowlogEntry{
      //唯一标识符
      long long id;
      //命令执行时的时间，格式为 UNIX 时间戳
      time_t time;
      //执行命令消耗的时间，以微秒为单位
      long long duration;
      //命令与命令参数
      robj **argv;
      //命令与命令参数的数量
      int argc;
  }slowlogEntry;
  ```

## 2. 慢查询日志的阅览与删除

- 查看日志的 `SLOWLOG GET` 命令伪代码：

  ```python
  def SLOWLOG_GET(number=None):
      # 用户未给定 number 参数，则打印服务器包含的全部慢查询日志
      if number is None:
          number = SLOWLOG_LEN()
      # 遍历服务器中的慢查询日志
      for log in redisServer.slowlog:
          if number <= 0:
              # 打印的日志数量已经足够，跳出循环
              break
          else:
              # 继续打印，将计数器值减一
              number -= 1
          # 打印日志
          printLog(log)
  ```

- 查看日志数量的  `SLOWLOG LEN` 命令伪代码：

  ```python
  def SLOWLOG_LEN():
      # slowlog 链表的长度就是慢查询日志的条目数量
      return len(redisServer.slowlog)
  ```

- 用于清除所有慢查询日志的 `SLOWLOG RESET` 命令的伪代码：

  ```python
  def SLOWLOG_RESET():
      # 遍历服务器中的所有慢查询日志
      for log in redisServer.slowlog:
          # 删除日志
          deleteLog(log)
  ```

## 3. 添加新日志

- 函数 `slowlogPushEntryIfNeeded`： **负责检查是否需要为此次执行的命令创建慢查询日志**

  伪代码：

  ```python
  # 记录执行命令前的时间
  before = unixtime_now_in_us()
  # 执行命令
  execute_command(argv,argc,client)
  # 记录执行命令后的时间
  after = unixtime_now_in_us()
  # 检查是否需要创建新的慢查询日志
  slowlogPushEntryIfNeeded(argv,argc,before - after)
  ```

  > 函数 `slowlogPushEntryIfNeeded` 的作用：
  >
  > - 检查命令的执行时长是否超过 `slowlog-log-slower-than` 选项所设置的时间
  >
  >   > 若超过，就为命令创建一个新的日志，并将新日志添加到 `slowlog` 链表的表头
  >
  > - 检查慢查询日志的长度是否超过 `slowlog-max-len` 选项所设置的长度
  >
  >   > 若超过，将多出来的日志从 `slowlog` 链表中方删除

# 二十、监视器

##1. 成为监视器

- 命令 `MONITOR`：客户端可将自己变为一个监视器，实时的接收并打印出服务器当前处理的命令请求的相关信息

  实现原理伪代码：

  ```python
  def MONITOR():
      # 打开客户端的监视器标志
      client.flags |= REDIS_MONITOR
      # 将客户端添加到服务器状态的 monitors 链表的末尾
      server.monitors.append(client)
      # 向客户端返回 ok
      send_reply("OK")
  ```

## 2. 向监视器发送命令信息

- 函数 `replicationFeedMonitors`： 将被处理的命令请求的相关信息发送给各监视器

  伪代码定义：

  ```python
  def replicationFeedMonitors(client,monitors,dbid,argv,argc):
      # 根据执行命令的客户端、当前数据库的号码、命令参数、命令参数的个数 创建要发送给各监视器的信息
      msg = create_message(client,dbid,argv,argc)
      # 遍历所有监视器
      for monitor in monitors:
          # 将信息发送给监视器
          send_message(monitor,msg)
  ```

