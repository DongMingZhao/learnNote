# 一、简介

## 1. 并发的历史

- 线程是控制和利用多处理器系统计算能力的最简单方式
- 下列因素推动了多程序共同运行：
  - 充分利用计算机资源
  - 保证多用户分时公平性
  - 有时候多程序解决问题更加方便
- 早期分时共享系统中，每个进程都是一个冯诺依曼机
- 寻找顺序和异步执行的平衡点，是让程序高效的关键。
- 线程的出现，分解了进程，而且更适应在多处理器系统上运行
- 同一进程中的线程，实现了良好的数据共享。然而多线程之间共享数据，会带来并发问题

## 2. 线程的优点

- 第一个优点是使用多核处理器
- 第二个优点是简化组件开发
- 第三个优点是，服务器为来自客户端的每一个连接都分配一个线程，并使用同步 IO ，是一种高效的方式
- 第四个优点是改善图形化软件的用户体验，防止“冻结”现象产生

##3. 线程的风险

- 第一个风险是多线程下执行顺序无法确定，会产生意外情况。使用 java 的同步机制可改善这个问题
- 第二个风险是死锁等程序无法继续执行的情况
- 第三个风险是多线程中，线程调度和同步机制会增加资源开销

# 二、线程安全性

## 1. 什么是线程安全性

- 在多个线程访问的时候，程序还能“**正确**”，那就是线程安全的
- 无状态（可以理解为没有字段的类）的对象一定是线程安全的

## 2. 原子性

- **原子操作：** 对于访问同一个状态的所有操作（包括该操作本身）来说，这个操作是一个以原子方式执行的操作

- **竞态条件：** 当某个计算的正确性取决于多个线程的交替执行时序时，就会发生竞态条件

  > 由于不恰当的执行时序而出现不正确的结果

- 基于一种可能失效的观察结果来做出判断或者执行某个计算，这种类型的竞态条件称为**先检查后执行**

  > 例子：**延迟初始化：** 将对象的初始化操作推迟到实际被使用时才进行，同时要确保只被初始化一次

- **复合操作：** 包含了一组以原子方式执行的操作以确保线程安全性

## 3. 加锁机制

- 要保持状态的一致性，就需要在单个原子操作中更新所有相关的状态变量

### 1. 内置锁

- java 提供了一种内置的锁机制来支持原子性：**同步代码块** 

  - 作为锁的对象引用
  - 作为由这个锁保护的代码块

  ```java
  synchronized(lock){
    
  }
  ```

- 每个java对象都可以用作一个实现同步的锁，这些锁称为**内置锁** 或 **监视器锁** 

### 2. 重入

- **重入** 意味着获取锁的操作的粒度是“线程“，而不是调用
- **重入** 的一种实现方法是：为每个锁关联一个获取计数器值和所有者线程
- **重入** 提升了加锁行为的封装性

## 4. 用锁来保护状态

- 对于可能被多个线程同时访问的可变状态变量，在访问它时都需要持有同一个锁，在这种情况下，我们称为**状态变量是由这个锁保护的** 
- 每个共享的和可变的变量都应该只由一个锁来保护，从而使维护人员知道是哪个锁
- 对于每个包含多个变量的不可变性条件，其中涉及的所有变量都需要由同一个锁来保护
- 将所有的可变状态都封装在对象内部，并通过对象的内置锁对所有访问可变状态的代码路径进行同步，使得在该对象上不会发生并发访问

## 5. 活跃性与性能

